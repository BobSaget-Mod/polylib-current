<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Lattice.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.15 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>Lattice.c</h1><a href="Lattice_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <font class="preprocessor">#include &lt;stdlib.h&gt;</font>
00002 <font class="preprocessor">#include &lt;polylib/polylib.h&gt;</font>
00003 
00004 
<a name="l00005"></a><a class="code" href="structfactor.html">00005</a> <font class="keyword">typedef</font> <font class="keyword">struct </font>{
<a name="l00006"></a><a class="code" href="structfactor.html#m0">00006</a>   <font class="keywordtype">int</font> count;
<a name="l00007"></a><a class="code" href="structfactor.html#m1">00007</a>   <font class="keywordtype">int</font> *fac;
00008 } <a class="code" href="structfactor.html">factor</a>;
00009 
00010 <font class="keyword">static</font> <a class="code" href="structfactor.html">factor</a> <a class="code" href="Lattice_8c.html#a0">allfactors</a> (<font class="keywordtype">int</font> num);
00011 
00012 <font class="comment">/* </font>
00013 <font class="comment"> * Print the contents of a list of Lattices 'Head'  </font>
00014 <font class="comment"> */</font>
<a name="l00015"></a><a class="code" href="Lattice_8c.html#a1">00015</a> <font class="keywordtype">void</font> <a class="code" href="Lattice_8c.html#a1">PrintLatticeUnion</a>(FILE *fp, <font class="keywordtype">char</font> *format, LatticeUnion *Head) {
00016   
00017   LatticeUnion *temp;
00018 
00019   <font class="keywordflow">for</font>(temp = Head; temp != NULL; temp = temp-&gt;next)
00020     <a class="code" href="matrix_8c.html#a2">Matrix_Print</a>(fp,format,(Matrix *)temp-&gt;M);
00021   <font class="keywordflow">return</font>;
00022 } <font class="comment">/* PrintLatticeUnion */</font>
00023 
00024 <font class="comment">/* </font>
00025 <font class="comment"> * Free the memory allocated to a list of lattices 'Head' </font>
00026 <font class="comment"> */</font>
<a name="l00027"></a><a class="code" href="Lattice_8c.html#a2">00027</a> <font class="keywordtype">void</font> <a class="code" href="Lattice_8c.html#a2">LatticeUnion_Free</a>(LatticeUnion *Head) {
00028 
00029   LatticeUnion  *temp;
00030 
00031   <font class="keywordflow">while</font> (Head != NULL) {
00032     temp = Head;
00033     Head = temp-&gt;next;
00034     <a class="code" href="matrix_8c.html#a1">Matrix_Free</a>(temp-&gt;M);
00035     free(temp);
00036   }
00037   <font class="keywordflow">return</font>;
00038 } <font class="comment">/* LatticeUnion_Free */</font>
00039 
00040 <font class="comment">/* </font>
00041 <font class="comment"> * Allocate a heads for a list of Lattices</font>
00042 <font class="comment"> */</font>
<a name="l00043"></a><a class="code" href="Lattice_8c.html#a3">00043</a> LatticeUnion *<a class="code" href="Lattice_8c.html#a3">LatticeUnion_Alloc</a>(<font class="keywordtype">void</font>) {
00044 
00045   LatticeUnion  *temp;
00046 
00047   temp = (LatticeUnion *)malloc(<font class="keyword">sizeof</font>(LatticeUnion));
00048   temp-&gt;M=NULL;
00049   temp-&gt;next=NULL;
00050   <font class="keywordflow">return</font> temp;
00051 } <font class="comment">/* LatticeUnion_Alloc */</font>
00052 
00053 <font class="comment">/*</font>
00054 <font class="comment"> * Given two Lattices 'A' and 'B', return True if they have the same affine </font>
00055 <font class="comment"> * part (the last column) otherwise return 'False'. </font>
00056 <font class="comment"> */</font>
<a name="l00057"></a><a class="code" href="Lattice_8c.html#a4">00057</a> Bool <a class="code" href="Lattice_8c.html#a4">sameAffinepart</a> (Lattice *A, Lattice *B) {
00058   
00059   <font class="keywordtype">int</font> i;
00060 
00061 <font class="preprocessor">#ifdef DOMDEBUG</font>
00062 <font class="preprocessor"></font>  FILE *fp;
00063   fp = fopen(<font class="stringliteral">"_debug"</font>,<font class="stringliteral">"a"</font>);
00064   fprintf(fp,<font class="stringliteral">"\nEntered SAMEAFFINEPART \n"</font>); 
00065   fclose(fp);
00066 <font class="preprocessor">#endif</font>
00067 <font class="preprocessor"></font>  
00068   <font class="keywordflow">for</font> (i = 0; i &lt; A-&gt;NbRows; i ++)
00069     <font class="keywordflow">if</font> (<a class="code" href="arithmetique_8h.html#a23">value_ne</a>(A-&gt;p[i][A-&gt;NbColumns-1],B-&gt;p[i][B-&gt;NbColumns-1]))
00070       <font class="keywordflow">return</font> False;
00071   <font class="keywordflow">return</font> True;
00072 } <font class="comment">/* sameAffinepart */</font> 
00073 
00074 <font class="comment">/*</font>
00075 <font class="comment"> * Return an empty lattice of dimension 'dimension-1'. An empty lattice is </font>
00076 <font class="comment"> * represented as [[0 0 ... 0] .... [0 ... 0][0 0.....0 1]]. </font>
00077 <font class="comment"> */</font> 
<a name="l00078"></a><a class="code" href="Lattice_8c.html#a5">00078</a> Lattice *<a class="code" href="Lattice_8c.html#a5">EmptyLattice</a>(<font class="keywordtype">int</font> dimension) {
00079 
00080   Lattice *result;
00081   <font class="keywordtype">int</font> i,j;
00082   
00083 <font class="preprocessor">#ifdef DOMDEBUG</font>
00084 <font class="preprocessor"></font>  FILE *fp;
00085   fp = fopen (<font class="stringliteral">"_debug"</font>, <font class="stringliteral">"a"</font>);
00086   fprintf (fp, <font class="stringliteral">"\nEntered NULLATTICE \n"</font>); 
00087   fclose (fp);
00088 <font class="preprocessor">#endif</font>
00089 <font class="preprocessor"></font>  
00090   result = (Lattice *) <a class="code" href="matrix_8c.html#a0">Matrix_Alloc</a>(dimension, dimension);
00091   <font class="keywordflow">for</font> (i = 0; i &lt; dimension; i ++)
00092     <font class="keywordflow">for</font> (j = 0; j &lt; dimension; j ++)
00093       <a class="code" href="arithmetique_8h.html#a12">value_set_si</a>(result-&gt;p[i][j],0);
00094   <a class="code" href="arithmetique_8h.html#a12">value_set_si</a>(result-&gt;p[i-1][i-1],1);
00095   <font class="keywordflow">return</font> result;
00096 } <font class="comment">/* EmptyLattice */</font> 
00097 
00098 <font class="comment">/*</font>
00099 <font class="comment"> * Return True if Lattice 'A' is empty, otherwise return False. </font>
00100 <font class="comment"> */</font>
<a name="l00101"></a><a class="code" href="Lattice_8c.html#a6">00101</a> Bool <a class="code" href="Lattice_8c.html#a6">isEmptyLattice</a> (Lattice *A) {
00102   
00103   <font class="keywordtype">int</font> i,j;  
00104   
00105 <font class="preprocessor">#ifdef DOMDEBUG</font>
00106 <font class="preprocessor"></font>  FILE *fp;
00107   fp = fopen(<font class="stringliteral">"_debug"</font>, <font class="stringliteral">"a"</font>);
00108   fprintf(fp,<font class="stringliteral">"\nEntered ISNULLATTICE \n"</font>); 
00109   fclose(fp);
00110 <font class="preprocessor">#endif</font>
00111 <font class="preprocessor"></font>  
00112   <font class="keywordflow">for</font> (i = 0; i &lt; A-&gt;NbRows-1; i ++)
00113     <font class="keywordflow">for</font> (j = 0; j &lt; A-&gt;NbColumns-1; j ++)
00114       <font class="keywordflow">if</font>(<a class="code" href="arithmetique_8h.html#a68">value_notzero_p</a>(A-&gt;p[i][j])) {
00115         <font class="keywordflow">return</font> False;
00116       }
00117   <font class="keywordflow">if</font> (<a class="code" href="arithmetique_8h.html#a69">value_one_p</a>(A-&gt;p[i][A-&gt;NbColumns-1])) {
00118     <font class="keywordflow">return</font> True ;
00119   }
00120   <font class="keywordflow">return</font> False ;
00121 } <font class="comment">/* isEmptyLaattice */</font> 
00122 
00123 <font class="comment">/*</font>
00124 <font class="comment"> * Given a Lattice 'A', check whether it is linear or not, i.e. whether the </font>
00125 <font class="comment"> * affine part is NULL or not. If affine part is empty, it returns True other-</font>
00126 <font class="comment"> * wise it returns False.</font>
00127 <font class="comment"> */</font>
<a name="l00128"></a><a class="code" href="Lattice_8c.html#a7">00128</a> Bool <a class="code" href="Lattice_8c.html#a7">isLinear</a>(Lattice  *A) {
00129   
00130   <font class="keywordtype">int</font> i;
00131 
00132 <font class="preprocessor">#ifdef DOMDEBUG</font>
00133 <font class="preprocessor"></font>  FILE *fp;
00134   fp = fopen (<font class="stringliteral">"_debug"</font>, <font class="stringliteral">"a"</font>);
00135   fprintf (fp, <font class="stringliteral">"\nEntered ISLINEAR \n"</font>); 
00136   fclose (fp);
00137 <font class="preprocessor">#endif</font>
00138 <font class="preprocessor"></font>
00139   <font class="keywordflow">for</font> (i = 0; i &lt; A-&gt;NbRows-1; i ++)
00140     <font class="keywordflow">if</font> (<a class="code" href="arithmetique_8h.html#a68">value_notzero_p</a>(A-&gt;p[i][A-&gt;NbColumns-1])) {
00141       <font class="keywordflow">return</font> False;
00142     }
00143   <font class="keywordflow">return</font> True;
00144 } <font class="comment">/* isLinear */</font> 
00145           
00146 <font class="comment">/* </font>
00147 <font class="comment"> * Return the affine Hermite normal form of the affine lattice 'A'. The unique </font>
00148 <font class="comment"> * affine Hermite form if a lattice is stored in 'H' and the unimodular matrix </font>
00149 <font class="comment"> * corresponding to 'A = H*U' is stored in the matrix 'U'. </font>
00150 <font class="comment"> * Algorithm : </font>
00151 <font class="comment"> *            1) Check if the Lattice is Linear or not.</font>
00152 <font class="comment"> *            2) If it is not Linear, then Homogenise the Lattice.</font>
00153 <font class="comment"> *            3) Call Hermite.</font>
00154 <font class="comment"> *            4) If the Lattice was Homogenised, the HNF H must be </font>
00155 <font class="comment"> *               Dehomogenised and also corresponding changes must</font>
00156 <font class="comment"> *               be made to the Unimodular Matrix U.</font>
00157 <font class="comment"> *            5) Return.</font>
00158 <font class="comment"> */</font> 
<a name="l00159"></a><a class="code" href="Lattice_8c.html#a8">00159</a> <font class="keywordtype">void</font> <a class="code" href="Lattice_8c.html#a8">AffineHermite</a> (Lattice *A, Lattice **H, Matrix **U) {
00160  
00161   Lattice *temp;
00162   Bool flag = True;
00163   
00164 <font class="preprocessor">#ifdef DOMDEBUG</font>
00165 <font class="preprocessor"></font>  FILE *fp;
00166   fp = fopen (<font class="stringliteral">"_debug"</font>, <font class="stringliteral">"a"</font>);
00167   fprintf (fp, <font class="stringliteral">"\nEntered AFFINEHERMITE \n"</font>); 
00168   fclose (fp);
00169 <font class="preprocessor">#endif</font>
00170 <font class="preprocessor"></font>
00171   <font class="keywordflow">if</font> (<a class="code" href="Lattice_8c.html#a7">isLinear</a>(A) == False)
00172     temp = <a class="code" href="Lattice_8c.html#a10">Homogenise</a>(A,True); 
00173   <font class="keywordflow">else</font> {
00174     flag = False ;
00175     temp = (Lattice *)<a class="code" href="Matop_8c.html#a5">Matrix_Copy</a>(A);
00176   }  
00177   <a class="code" href="NormalForms_8c.html#a16">Hermite</a>((Matrix *)temp,(Matrix **) H, U);
00178   <font class="keywordflow">if</font> (flag == True) {
00179     <a class="code" href="matrix_8c.html#a1">Matrix_Free</a> ((Matrix *) temp);
00180     temp = <a class="code" href="Lattice_8c.html#a10">Homogenise</a>(H[0],False);
00181     <a class="code" href="matrix_8c.html#a1">Matrix_Free</a>((Matrix *) H[0]);
00182     H[0] = (Lattice *)<a class="code" href="Matop_8c.html#a5">Matrix_Copy</a>(temp);
00183     <a class="code" href="matrix_8c.html#a1">Matrix_Free</a>((Matrix *) temp);
00184     temp = <a class="code" href="Lattice_8c.html#a10">Homogenise</a>(U[0],False);
00185     <a class="code" href="matrix_8c.html#a1">Matrix_Free</a> ((Matrix *) U[0]);
00186     U[0] = (Matrix *)<a class="code" href="Matop_8c.html#a5">Matrix_Copy</a>(temp);
00187   }  
00188   <a class="code" href="matrix_8c.html#a1">Matrix_Free</a>((Matrix *) temp);
00189   <font class="keywordflow">return</font>;
00190 } <font class="comment">/* AffineHermite */</font>
00191 
00192 <font class="comment">/*</font>
00193 <font class="comment"> * Given a Polylib matrix 'A' that rerepresents an affine function, return the</font>
00194 <font class="comment"> * affine Smith normal form 'Delta' of 'A' and unimodular matrices 'U' and 'V'</font>
00195 <font class="comment"> * such that 'A = U*Delta*V'. </font>
00196 <font class="comment"> * Algorithm:</font>
00197 <font class="comment"> *           (1) Homogenise the Lattice.</font>
00198 <font class="comment"> *           (2) Call Smith</font>
00199 <font class="comment"> *           (3) The Smith Normal Form Delta must be Dehomogenised and also </font>
00200 <font class="comment"> *               corresponding changes must be made to the Unimodular Matrices </font>
00201 <font class="comment"> *               U and V.</font>
00202 <font class="comment"> *           4) Bring Delta into AffineSmith Form.</font>
00203 <font class="comment"> */</font>
<a name="l00204"></a><a class="code" href="Lattice_8c.html#a9">00204</a> <font class="keywordtype">void</font> <a class="code" href="Lattice_8c.html#a9">AffineSmith</a>(Lattice *A, Lattice **U, Lattice **V, Lattice **Diag) {
00205  
00206   Lattice *temp;
00207   Lattice *Uinv;
00208   <font class="keywordtype">int</font> i,j;
00209   <a class="code" href="arithmetique_8h.html#a93">Value</a> sum, tmp, quo, rem;
00210   
00211 <font class="preprocessor">#ifdef DOMDEBUG</font>
00212 <font class="preprocessor"></font>  FILE *fp;
00213   fp = fopen(<font class="stringliteral">"_debug"</font>, <font class="stringliteral">"a"</font>);
00214   fprintf(fp,<font class="stringliteral">"\nEntered AFFINESMITH \n"</font>); 
00215   fclose(fp);
00216 <font class="preprocessor">#endif</font>
00217 <font class="preprocessor"></font>  
00218   <a class="code" href="arithmetique_8h.html#a10">value_init</a>(sum); <a class="code" href="arithmetique_8h.html#a10">value_init</a>(tmp);
00219   <a class="code" href="arithmetique_8h.html#a10">value_init</a>(quo); <a class="code" href="arithmetique_8h.html#a10">value_init</a>(rem);
00220   temp = <a class="code" href="Lattice_8c.html#a10">Homogenise</a>(A,True);  
00221   <a class="code" href="NormalForms_8c.html#a15">Smith</a>((Matrix *)temp, (Matrix **)U, (Matrix **)V, (Matrix **)Diag);
00222   <a class="code" href="matrix_8c.html#a1">Matrix_Free</a>((Matrix *)temp);
00223   
00224   temp = <a class="code" href="Lattice_8c.html#a10">Homogenise</a> (*U, False);
00225   <a class="code" href="matrix_8c.html#a1">Matrix_Free</a> ((Matrix *) *U);
00226   *U = (Lattice *)<a class="code" href="Matop_8c.html#a5">Matrix_Copy</a> ((Matrix *)temp);
00227   <a class="code" href="matrix_8c.html#a1">Matrix_Free</a> ((Matrix *)temp);
00228   
00229   temp = <a class="code" href="Lattice_8c.html#a10">Homogenise</a> (*V, False);
00230   <a class="code" href="matrix_8c.html#a1">Matrix_Free</a> ((Matrix *)*V);
00231   *V = (Lattice *) <a class="code" href="Matop_8c.html#a5">Matrix_Copy</a> ((Matrix *)temp);
00232   <a class="code" href="matrix_8c.html#a1">Matrix_Free</a> ((Matrix *)temp);
00233   
00234   temp = <a class="code" href="Lattice_8c.html#a10">Homogenise</a> (*Diag, False);
00235   <a class="code" href="matrix_8c.html#a1">Matrix_Free</a> ((Matrix *)*Diag);
00236   *Diag = (Lattice *)<a class="code" href="Matop_8c.html#a5">Matrix_Copy</a> ((Matrix *)temp);
00237   <a class="code" href="matrix_8c.html#a1">Matrix_Free</a> ((Matrix *)temp);
00238   
00239   temp = (Lattice *) <a class="code" href="Matop_8c.html#a5">Matrix_Copy</a> ((Matrix *) *U);
00240   Uinv = (Lattice *) <a class="code" href="matrix_8c.html#a0">Matrix_Alloc</a> (U[0]-&gt;NbRows, U[0]-&gt;NbColumns);
00241   <a class="code" href="matrix_8c.html#a13">Matrix_Inverse</a>( (Matrix *) temp, (Matrix *)  Uinv);
00242   <a class="code" href="matrix_8c.html#a1">Matrix_Free</a> ((Matrix *) temp);
00243   
00244   <font class="keywordflow">for</font> (i = 0; i &lt; U[0]-&gt;NbRows-1; i ++) {
00245     <a class="code" href="arithmetique_8h.html#a12">value_set_si</a>(sum,0);
00246     <font class="keywordflow">for</font>(j = 0; j &lt; U[0]-&gt;NbColumns-1; j ++) {
00247       <a class="code" href="arithmetique_8h.html#a47">value_multiply</a>(tmp,Uinv-&gt;p[i][j],U[0]-&gt;p[j][U[0]-&gt;NbColumns-1]);
00248       <a class="code" href="arithmetique_8h.html#a43">value_addto</a>(sum,sum,tmp);
00249     }
00250     <a class="code" href="arithmetique_8h.html#a11">value_assign</a>(Diag[0]-&gt;p[i][j],sum);
00251   }
00252   <a class="code" href="matrix_8c.html#a1">Matrix_Free</a>((Matrix *) Uinv);  
00253   <font class="keywordflow">for</font>(i = 0; i &lt; U[0]-&gt;NbRows-1; i ++) 
00254     <a class="code" href="arithmetique_8h.html#a12">value_set_si</a>(U[0]-&gt;p[i][U[0]-&gt;NbColumns-1],0);
00255   <font class="keywordflow">for</font>(i = 0; i &lt; Diag[0]-&gt;NbRows-1; i ++) {
00256     <a class="code" href="arithmetique_8h.html#a51">value_division</a>(quo,Diag[0]-&gt;p[i][Diag[0]-&gt;NbColumns-1],Diag[0]-&gt;p[i][i]);
00257     <a class="code" href="arithmetique_8h.html#a52">value_modulus</a>(rem,Diag[0]-&gt;p[i][Diag[0]-&gt;NbColumns-1],Diag[0]-&gt;p[i][i]);
00258     
00259     fprintf(stdout,<font class="stringliteral">" pourcent "</font>); 
00260     <a class="code" href="arithmetique_8h.html#a16">value_print</a>(stdout,<a class="code" href="arithmetique_8h.html#a5">VALUE_FMT</a>,rem);
00261     fprintf(stdout,<font class="stringliteral">" quotient "</font>);
00262     <a class="code" href="arithmetique_8h.html#a16">value_print</a>(stdout,<a class="code" href="arithmetique_8h.html#a5">VALUE_FMT</a>,quo);
00263     fprintf(stdout,<font class="stringliteral">" \n"</font>);
00264     
00265     <font class="comment">/* Apparently the % operator is strange when sign are different */</font>
00266     <font class="keywordflow">if</font>(<a class="code" href="arithmetique_8h.html#a64">value_neg_p</a>(rem)) {
00267       <a class="code" href="arithmetique_8h.html#a43">value_addto</a>(rem,rem,Diag[0]-&gt;p[i][i]);
00268       <a class="code" href="arithmetique_8h.html#a50">value_decrement</a>(quo,quo);
00269     };
00270     fprintf(stdout,<font class="stringliteral">"apres  pourcent "</font>); 
00271     <a class="code" href="arithmetique_8h.html#a16">value_print</a>(stdout,<a class="code" href="arithmetique_8h.html#a5">VALUE_FMT</a>,rem);
00272     fprintf(stdout,<font class="stringliteral">" quotient "</font>);
00273     <a class="code" href="arithmetique_8h.html#a16">value_print</a>(stdout,<a class="code" href="arithmetique_8h.html#a5">VALUE_FMT</a>,quo);
00274     fprintf(stdout,<font class="stringliteral">" \n"</font>);
00275     <a class="code" href="arithmetique_8h.html#a11">value_assign</a>( Diag[0]-&gt;p[i][Diag[0]-&gt;NbColumns-1],rem);
00276     <a class="code" href="arithmetique_8h.html#a11">value_assign</a>(V[0]-&gt;p[i][V[0]-&gt;NbColumns-1],quo);
00277   }  
00278   <a class="code" href="arithmetique_8h.html#a14">value_clear</a>(sum); <a class="code" href="arithmetique_8h.html#a14">value_clear</a>(tmp);
00279   <a class="code" href="arithmetique_8h.html#a14">value_clear</a>(quo); <a class="code" href="arithmetique_8h.html#a14">value_clear</a>(rem);
00280   <font class="keywordflow">return</font>;
00281 } <font class="comment">/* AffineSmith */</font>
00282 
00283 <font class="comment">/*</font>
00284 <font class="comment"> * Given a lattice 'A' and a boolean variable 'Forward', homogenise the lattice</font>
00285 <font class="comment"> * if 'Forward' is True, otherwise if 'Forward' is False, dehomogenise the </font>
00286 <font class="comment"> * lattice 'A'. </font>
00287 <font class="comment"> * Algorithm: </font>
00288 <font class="comment"> *            (1) If Forward == True</font>
00289 <font class="comment"> *                Put the last row first. </font>
00290 <font class="comment"> *                Put the last columns first. </font>
00291 <font class="comment"> *            (2) Else </font>
00292 <font class="comment"> *                Put the first row last. </font>
00293 <font class="comment"> *                Put the first column last.</font>
00294 <font class="comment"> *            (3) Return the result. </font>
00295 <font class="comment"> */</font>
<a name="l00296"></a><a class="code" href="Lattice_8c.html#a10">00296</a> Lattice *<a class="code" href="Lattice_8c.html#a10">Homogenise</a>(Lattice *A, Bool Forward) {
00297   
00298   Lattice *result;
00299 
00300 <font class="preprocessor">#ifdef DOMDEBUG</font>
00301 <font class="preprocessor"></font>  FILE *fp;
00302   fp = fopen(<font class="stringliteral">"_debug"</font>,<font class="stringliteral">"a"</font>);
00303   fprintf(fp,<font class="stringliteral">"\nEntered HOMOGENISE \n"</font>); 
00304   fclose(fp);
00305 <font class="preprocessor">#endif</font>
00306 <font class="preprocessor"></font>    
00307   result = (Lattice *)<a class="code" href="Matop_8c.html#a5">Matrix_Copy</a>(A);  
00308   <font class="keywordflow">if</font> (Forward == True ) { 
00309     <a class="code" href="Matop_8c.html#a10">PutColumnFirst</a>((Matrix *)result, A-&gt;NbColumns-1);
00310     <a class="code" href="Matop_8c.html#a9">PutRowFirst</a>((Matrix *)result, result-&gt;NbRows-1);
00311   }
00312   <font class="keywordflow">else</font>  { 
00313     <a class="code" href="Matop_8c.html#a11">PutColumnLast</a>((Matrix *)result,0);
00314     <a class="code" href="Matop_8c.html#a8">PutRowLast</a>((Matrix *)result,0);
00315   }   
00316   <font class="keywordflow">return</font> result;
00317 } <font class="comment">/* Homogenise */</font> 
00318 
00319 <font class="comment">/*</font>
00320 <font class="comment"> * Given two lattices 'A' and 'B', verify if lattice 'A' is included in 'B' or</font>
00321 <font class="comment"> * not. If 'A' is included in 'B' the 'A' intersection 'B', will be 'A'. So, </font>
00322 <font class="comment"> * compute 'A' intersection 'B' and check if it is the same as 'A'. </font>
00323 <font class="comment"> */</font>
<a name="l00324"></a><a class="code" href="Lattice_8c.html#a11">00324</a> Bool <a class="code" href="Lattice_8c.html#a11">LatticeIncludes</a>(Lattice *A, Lattice *B) {
00325   
00326   Lattice *temp, *UA, *HA;
00327   Bool flag = False;
00328 
00329 <font class="preprocessor">#ifdef DOMDEBUG</font>
00330 <font class="preprocessor"></font>  FILE *fp;
00331   fp = fopen(<font class="stringliteral">"_debug"</font>, <font class="stringliteral">"a"</font>);
00332   fprintf(fp,<font class="stringliteral">"\nEntered LATTICE INCLUDES \n"</font>); 
00333   fclose(fp);
00334 <font class="preprocessor">#endif</font>
00335 <font class="preprocessor"></font>  
00336   <a class="code" href="Lattice_8c.html#a8">AffineHermite</a>(A,&amp;HA,&amp;UA);  
00337   temp = <a class="code" href="Lattice_8c.html#a16">LatticeIntersection</a>(B,HA); 
00338   <font class="keywordflow">if</font> (<a class="code" href="Lattice_8c.html#a12">sameLattice</a>(temp, HA) == True)
00339     flag = True;
00340   
00341   <a class="code" href="matrix_8c.html#a1">Matrix_Free</a>((Matrix *)temp);
00342   <a class="code" href="matrix_8c.html#a1">Matrix_Free</a>((Matrix *)UA);
00343   <a class="code" href="matrix_8c.html#a1">Matrix_Free</a>((Matrix *)HA);
00344   <font class="keywordflow">return</font> flag; 
00345 } <font class="comment">/* LatticeIncludes */</font>
00346 
00347 <font class="comment">/*</font>
00348 <font class="comment"> * Given two lattices 'A' and 'B', verify if 'A' and 'B' are the same lattice.</font>
00349 <font class="comment"> * Algorithm: </font>
00350 <font class="comment"> *           The Affine Hermite form of two full dimensional matrices are </font>
00351 <font class="comment"> * unique. So, take the Affine Hermite form of both 'A' and 'B' and compare the</font>
00352 <font class="comment"> * matrices. If they are equal, the function returns True, else it returns </font>
00353 <font class="comment"> * False. </font>
00354 <font class="comment"> */</font>
<a name="l00355"></a><a class="code" href="Lattice_8c.html#a12">00355</a> Bool <a class="code" href="Lattice_8c.html#a12">sameLattice</a>(Lattice *A, Lattice *B) {
00356   
00357   Lattice *HA, *HB, *UA, *UB;
00358   <font class="keywordtype">int</font> i,j;
00359   Bool result = True;
00360   
00361 <font class="preprocessor">#ifdef DOMDEBUG</font>
00362 <font class="preprocessor"></font>  FILE *fp;
00363   fp = fopen(<font class="stringliteral">"_debug"</font>, <font class="stringliteral">"a"</font>);
00364   fprintf(fp,<font class="stringliteral">"\nEntered SAME LATTICE \n"</font>); 
00365   fclose(fp);
00366 <font class="preprocessor">#endif</font>
00367 <font class="preprocessor"></font>  
00368   <a class="code" href="Lattice_8c.html#a8">AffineHermite</a>(A, &amp;HA, &amp;UA);
00369   <a class="code" href="Lattice_8c.html#a8">AffineHermite</a>(B, &amp;HB, &amp;UB);
00370     
00371   <font class="keywordflow">for</font> (i = 0 ; i &lt; A-&gt;NbRows; i ++)
00372     <font class="keywordflow">for</font> (j =  0; j &lt; A-&gt;NbColumns; j ++)
00373       <font class="keywordflow">if</font> (<a class="code" href="arithmetique_8h.html#a23">value_ne</a>(HA-&gt;p[i][j],HB-&gt;p[i][j])) {  
00374         result = False; 
00375         <font class="keywordflow">break</font>; 
00376       }  
00377   
00378   <a class="code" href="matrix_8c.html#a1">Matrix_Free</a> ((Matrix *) HA); 
00379   <a class="code" href="matrix_8c.html#a1">Matrix_Free</a> ((Matrix *) HB); 
00380   <a class="code" href="matrix_8c.html#a1">Matrix_Free</a> ((Matrix *) UA); 
00381   <a class="code" href="matrix_8c.html#a1">Matrix_Free</a> ((Matrix *) UB); 
00382   
00383   <font class="keywordflow">return</font> result;
00384 } <font class="comment">/* sameLattice */</font> 
00385 
00386 <font class="comment">/*</font>
00387 <font class="comment"> * Given a matrix 'A' and an integer 'dimension', do the following: </font>
00388 <font class="comment"> * If dimension &lt; A-&gt;dimension), output a (dimension * dimension) submatrix of </font>
00389 <font class="comment"> * A. Otherwise the output matrix is [A 0][0 ID]. The order if the identity </font>
00390 <font class="comment"> * matrix is (dimension - A-&gt;dimension). The input matrix is not necessarily </font>
00391 <font class="comment"> * a Polylib matrix but the output is a polylib matrix. </font>
00392 <font class="comment"> */</font>
<a name="l00393"></a><a class="code" href="Lattice_8c.html#a13">00393</a> Lattice *<a class="code" href="Lattice_8c.html#a13">ChangeLatticeDimension</a>(Lattice *A, <font class="keywordtype">int</font> dimension) {
00394   
00395   <font class="keywordtype">int</font> i, j;
00396   Lattice *Result ;
00397   
00398   Result = <a class="code" href="matrix_8c.html#a0">Matrix_Alloc</a>(dimension, dimension);
00399   <font class="keywordflow">if</font>(dimension &lt;= A-&gt;NbRows) {
00400     <font class="keywordflow">for</font> (i = 0; i &lt; dimension; i ++)
00401       <font class="keywordflow">for</font> (j = 0; j &lt; dimension; j ++)
00402         <a class="code" href="arithmetique_8h.html#a11">value_assign</a>(Result-&gt;p[i][j],A-&gt;p[i][j]);
00403     <font class="keywordflow">return</font> Result;
00404   }  
00405   <font class="keywordflow">for</font> (i = 0; i &lt; A-&gt;NbRows; i ++)
00406     <font class="keywordflow">for</font> (j = 0; j &lt; A-&gt;NbRows; j ++)
00407       <a class="code" href="arithmetique_8h.html#a11">value_assign</a>(Result-&gt;p[i][j],A-&gt;p[i][j]);
00408   
00409   <font class="keywordflow">for</font> (i = A-&gt;NbRows; i &lt; dimension; i ++)
00410     <font class="keywordflow">for</font> (j = 0; j &lt; dimension; j ++) {
00411         <a class="code" href="arithmetique_8h.html#a12">value_set_si</a>(Result-&gt;p[i][j],0);
00412         <a class="code" href="arithmetique_8h.html#a12">value_set_si</a>(Result-&gt;p[j][i],0);
00413     }  
00414   <font class="keywordflow">for</font> (i = A-&gt;NbRows; i &lt; dimension; i ++)
00415      <a class="code" href="arithmetique_8h.html#a12">value_set_si</a>(Result-&gt;p[i][i],1);   
00416   <font class="keywordflow">return</font> Result;
00417 } <font class="comment">/* ChangeLatticeDimension */</font>
00418 
00419 <font class="comment">/* </font>
00420 <font class="comment"> * Given an affine lattice 'A', return a matrix of the linear part of the </font>
00421 <font class="comment"> * lattice.  </font>
00422 <font class="comment"> */</font>
<a name="l00423"></a><a class="code" href="Lattice_8c.html#a14">00423</a> Lattice *<a class="code" href="Lattice_8c.html#a14">ExtractLinearPart</a>(Lattice *A) {
00424 
00425   Lattice *Result;
00426   <font class="keywordtype">int</font> i, j; 
00427   Result = (Lattice *) <a class="code" href="matrix_8c.html#a0">Matrix_Alloc</a>(A-&gt;NbRows-1, A-&gt;NbColumns-1);
00428   <font class="keywordflow">for</font> (i = 0; i &lt; A-&gt;NbRows-1; i ++)
00429     <font class="keywordflow">for</font> (j = 0; j &lt; A-&gt;NbColumns-1; j ++)
00430       <a class="code" href="arithmetique_8h.html#a11">value_assign</a>(Result-&gt;p[i][j],A-&gt;p[i][j]);  
00431   <font class="keywordflow">return</font> Result;
00432 } <font class="comment">/* ExtractLinearPart */</font>
00433 
00434 <font class="keyword">static</font> Matrix *<a class="code" href="Lattice_8c.html#a17">MakeDioEqforInter</a>(Matrix *A, Matrix *B);
00435 
00436 <font class="comment">/*</font>
00437 <font class="comment"> * Given two lattices 'A' and 'B', return the intersection of the two lattcies.</font>
00438 <font class="comment"> * The dimension of 'A' and 'B' should be the same. </font>
00439 <font class="comment"> * Algorithm:</font>
00440 <font class="comment"> *           (1) Verify if the lattcies 'A' and 'B' have the same affine part. </font>
00441 <font class="comment"> *               If they have same affine part, then only their Linear parts </font>
00442 <font class="comment"> *               need to be intersected. If they don't have the same affine</font>
00443 <font class="comment"> *               part then the affine part has to be taken into consideration. </font>
00444 <font class="comment"> *               For this, homogenise the lattices to get their Hermite Forms</font>
00445 <font class="comment"> *               and then find their intersection.</font>
00446 <font class="comment"> *</font>
00447 <font class="comment"> *           (2) Step(2) involves, solving the Diophantine Equations in order </font>
00448 <font class="comment"> *               to extract the intersection of the Lattices. The Diophantine</font>
00449 <font class="comment"> *               equations are formed taking into consideration whether the </font>
00450 <font class="comment"> *               affine part has to be included or not. </font>
00451 <font class="comment"> *</font>
00452 <font class="comment"> *           (3) Solve the Diophantine equations. </font>
00453 <font class="comment"> *</font>
00454 <font class="comment"> *           (4) Extract the necessary information from the result. </font>
00455 <font class="comment"> * </font>
00456 <font class="comment"> *           (5) If the lattices have different affine parts and they were </font>
00457 <font class="comment"> *               homogenised, the result is dehomogenised. </font>
00458 <font class="comment"> */</font> 
<a name="l00459"></a><a class="code" href="Lattice_8c.html#a16">00459</a> Lattice *<a class="code" href="Lattice_8c.html#a16">LatticeIntersection</a>(Lattice *X, Lattice *Y) {
00460   
00461   <font class="keywordtype">int</font> i, j, exist;
00462   Lattice *result = NULL, *U = NULL ;
00463   Lattice *A = NULL, *B = NULL, *H = NULL;
00464   Matrix *fordio;
00465   Vector *X1 = NULL;
00466   
00467 <font class="preprocessor">#ifdef DOMDEBUG</font>
00468 <font class="preprocessor"></font>  FILE *fp;
00469   fp = fopen(<font class="stringliteral">"_debug"</font>, <font class="stringliteral">"a"</font>);
00470   fprintf(fp,<font class="stringliteral">"\nEntered LATTICEINTERSECTION \n"</font>); 
00471   fclose(fp);
00472 <font class="preprocessor">#endif</font>
00473 <font class="preprocessor"></font>
00474   <font class="keywordflow">if</font> (X-&gt;NbRows != X-&gt;NbColumns) {
00475     fprintf(stderr, <font class="stringliteral">"\nIn LatticeIntersection : The Input Matrix X is a not a well defined Lattice\n"</font>);
00476     <font class="keywordflow">return</font> <a class="code" href="Lattice_8c.html#a5">EmptyLattice</a>(X-&gt;NbRows);
00477   }
00478   
00479   <font class="keywordflow">if</font> (Y-&gt;NbRows != Y-&gt;NbColumns) {
00480     fprintf (stderr, <font class="stringliteral">"\nIn LatticeIntersection : The Input Matrix Y is a not a well defined Lattice\n"</font>);
00481     <font class="keywordflow">return</font> <a class="code" href="Lattice_8c.html#a5">EmptyLattice</a>(X-&gt;NbRows);
00482   }
00483   
00484   <font class="keywordflow">if</font> (Y-&gt;NbRows != X-&gt;NbRows) {
00485     fprintf (stderr, <font class="stringliteral">"\nIn LatticeIntersection : The Input Lattices X and Y are of incompatible dimensions\n"</font>);
00486     <font class="keywordflow">return</font> <a class="code" href="Lattice_8c.html#a5">EmptyLattice</a>(X-&gt;NbRows);
00487   }
00488   
00489   <font class="keywordflow">if</font> (<a class="code" href="Matop_8c.html#a7">isinHnf</a>(X))
00490     A = (Lattice *) <a class="code" href="Matop_8c.html#a5">Matrix_Copy</a>(X);
00491   <font class="keywordflow">else</font> {
00492     <a class="code" href="Lattice_8c.html#a8">AffineHermite</a>(X, &amp;H, &amp;U);
00493     A = (Lattice *)<a class="code" href="Matop_8c.html#a5">Matrix_Copy</a> (H);
00494     <a class="code" href="matrix_8c.html#a1">Matrix_Free</a>((Matrix *) H);
00495     <a class="code" href="matrix_8c.html#a1">Matrix_Free</a>((Matrix *) U);
00496   }
00497   
00498   <font class="keywordflow">if</font> (<a class="code" href="Matop_8c.html#a7">isinHnf</a>(Y))
00499     B = (Lattice *)<a class="code" href="Matop_8c.html#a5">Matrix_Copy</a>(Y);
00500   <font class="keywordflow">else</font> {
00501     <a class="code" href="Lattice_8c.html#a8">AffineHermite</a>(Y, &amp;H, &amp;U);
00502     B = (Lattice *)<a class="code" href="Matop_8c.html#a5">Matrix_Copy</a> (H);
00503     <a class="code" href="matrix_8c.html#a1">Matrix_Free</a>((Matrix *) H);
00504     <a class="code" href="matrix_8c.html#a1">Matrix_Free</a>((Matrix *) U);
00505   }
00506   
00507   <font class="keywordflow">if</font> ((<a class="code" href="Lattice_8c.html#a6">isEmptyLattice</a>(A)) || (<a class="code" href="Lattice_8c.html#a6">isEmptyLattice</a> (B))) {
00508     result = <a class="code" href="Lattice_8c.html#a5">EmptyLattice</a>(X-&gt;NbRows);
00509     <a class="code" href="matrix_8c.html#a1">Matrix_Free</a> ((Matrix *) A); 
00510     <a class="code" href="matrix_8c.html#a1">Matrix_Free</a> ((Matrix *) B);
00511     <font class="keywordflow">return</font> result;   
00512   }
00513   fordio = <a class="code" href="Lattice_8c.html#a17">MakeDioEqforInter</a> (A, B);
00514   <a class="code" href="matrix_8c.html#a1">Matrix_Free</a> (A);
00515   <a class="code" href="matrix_8c.html#a1">Matrix_Free</a> (B);
00516   exist = <a class="code" href="SolveDio_8c.html#a1">SolveDiophantine</a>(fordio,(Matrix **) &amp;U, &amp;X1);
00517   <font class="keywordflow">if</font> (exist &lt; 0) { <font class="comment">/* Intersection is NULL */</font>    
00518     result = (<a class="code" href="Lattice_8c.html#a5">EmptyLattice</a>(X-&gt;NbRows)); 
00519     <font class="keywordflow">return</font> result;
00520   }
00521   
00522   result = (Lattice *)<a class="code" href="matrix_8c.html#a0">Matrix_Alloc</a>(X-&gt;NbRows, X-&gt;NbColumns);
00523   <font class="keywordflow">for</font> (i = 0; i &lt; result-&gt;NbRows-1; i ++)
00524     <font class="keywordflow">for</font> (j = 0; j &lt; result-&gt;NbColumns-1; j ++)
00525       <a class="code" href="arithmetique_8h.html#a11">value_assign</a>(result-&gt;p[i][j],U-&gt;p[i][j]);
00526   
00527   <font class="keywordflow">for</font> (i = 0; i &lt; result-&gt;NbRows-1; i ++)
00528     <a class="code" href="arithmetique_8h.html#a11">value_assign</a>(result-&gt;p[i][result-&gt;NbColumns-1],X1-&gt;p[i]); 
00529   <font class="keywordflow">for</font> (i = 0; i &lt; result-&gt;NbColumns-1; i ++)
00530     <a class="code" href="arithmetique_8h.html#a12">value_set_si</a>(result-&gt;p[result-&gt;NbRows-1][i],0);
00531   <a class="code" href="arithmetique_8h.html#a12">value_set_si</a>(result-&gt;p[result-&gt;NbRows-1][result-&gt;NbColumns-1],1);
00532   
00533   <a class="code" href="matrix_8c.html#a1">Matrix_Free</a>((Matrix *) U);
00534   <a class="code" href="vector_8c.html#a6">Vector_Free</a>(X1);
00535   <a class="code" href="matrix_8c.html#a1">Matrix_Free</a>(fordio);
00536   
00537   <a class="code" href="Lattice_8c.html#a8">AffineHermite</a>(result,&amp;H,&amp;U);  
00538   <a class="code" href="matrix_8c.html#a1">Matrix_Free</a>((Matrix *)result);
00539   result = (Lattice *)<a class="code" href="Matop_8c.html#a5">Matrix_Copy</a>(H); 
00540   
00541   <a class="code" href="matrix_8c.html#a1">Matrix_Free</a>((Matrix *) H);
00542   <a class="code" href="matrix_8c.html#a1">Matrix_Free</a>((Matrix *) U);
00543   
00544   <font class="comment">/* Check whether the Lattice is NULL or not */</font>
00545   
00546   <font class="keywordflow">if</font> (<a class="code" href="Lattice_8c.html#a6">isEmptyLattice</a> (result)) {
00547     <a class="code" href="matrix_8c.html#a1">Matrix_Free</a> ((Matrix *)result);
00548     <font class="keywordflow">return</font> (<a class="code" href="Lattice_8c.html#a5">EmptyLattice</a> (X-&gt;NbRows));
00549   }  
00550   <font class="keywordflow">return</font> result;
00551 } <font class="comment">/* LatticeIntersection */</font>
00552 
<a name="l00553"></a><a class="code" href="Lattice_8c.html#a17">00553</a> <font class="keyword">static</font> Matrix * <a class="code" href="Lattice_8c.html#a17">MakeDioEqforInter</a> (Lattice *A, Lattice *B) {
00554   
00555   Matrix *Dio ;
00556   <font class="keywordtype">int</font> i,j;
00557   
00558 <font class="preprocessor">#ifdef DOMDEBUG</font>
00559 <font class="preprocessor"></font>  FILE *fp;
00560   fp = fopen(<font class="stringliteral">"_debug"</font>, <font class="stringliteral">"a"</font>);
00561   fprintf(fp,<font class="stringliteral">"\nEntered MAKEDIOEQFORINTER \n"</font>); 
00562   fclose(fp);
00563 <font class="preprocessor">#endif</font>
00564 <font class="preprocessor"></font>  
00565  Dio = <a class="code" href="matrix_8c.html#a0">Matrix_Alloc</a>(2*(A-&gt;NbRows-1) + 1, 3 * (A-&gt;NbColumns-1)+1);
00566  
00567  <font class="keywordflow">for</font> (i = 0; i &lt; Dio-&gt;NbRows; i ++)
00568    <font class="keywordflow">for</font> (j = 0; j &lt; Dio-&gt;NbColumns; j ++)
00569      <a class="code" href="arithmetique_8h.html#a12">value_set_si</a>(Dio-&gt;p[i][j],0);
00570  
00571  <font class="keywordflow">for</font> (i = 0; i &lt; A-&gt;NbRows-1; i++) {
00572    <a class="code" href="arithmetique_8h.html#a12">value_set_si</a>(Dio-&gt;p[i][i],1);
00573    <a class="code" href="arithmetique_8h.html#a12">value_set_si</a>(Dio-&gt;p[i+A-&gt;NbRows-1][i],1);  
00574  } 
00575  <font class="keywordflow">for</font> (i = 0; i &lt; A-&gt;NbRows-1 ; i ++)
00576    <font class="keywordflow">for</font> (j = 0; j &lt; A-&gt;NbRows-1; j ++) {
00577      <a class="code" href="arithmetique_8h.html#a54">value_oppose</a>(Dio-&gt;p[i][j+A-&gt;NbRows-1],A-&gt;p[i][j]);
00578      <a class="code" href="arithmetique_8h.html#a54">value_oppose</a>(Dio-&gt;p[i+(A-&gt;NbRows-1)][j+2*(A-&gt;NbRows-1)],B-&gt;p[i][j]);
00579    }
00580  
00581  <font class="comment">/* Adding the affine part */</font>
00582  
00583  <font class="keywordflow">for</font> (i = 0; i &lt; A-&gt;NbColumns-1; i++) {
00584    <a class="code" href="arithmetique_8h.html#a54">value_oppose</a>(Dio-&gt;p[i][Dio-&gt;NbColumns-1],A-&gt;p[i][A-&gt;NbColumns-1]);
00585    <a class="code" href="arithmetique_8h.html#a54">value_oppose</a>(Dio-&gt;p[i+A-&gt;NbRows-1][Dio-&gt;NbColumns-1],B-&gt;p[i][A-&gt;NbColumns-1]) ;
00586  } 
00587  <a class="code" href="arithmetique_8h.html#a12">value_set_si</a>(Dio-&gt;p[Dio-&gt;NbRows-1][Dio-&gt;NbColumns-1],1); 
00588  <font class="keywordflow">return</font> Dio;
00589 } <font class="comment">/* MakeDioEqforInter */</font>
00590 
00591 <font class="keyword">static</font> <font class="keywordtype">void</font> <a class="code" href="Lattice_8c.html#a18">AddLattice</a>(LatticeUnion *,Matrix *,  Matrix *, <font class="keywordtype">int</font> , <font class="keywordtype">int</font>);
00592 LatticeUnion *<a class="code" href="Lattice_8c.html#a22">SplitLattice</a>(Matrix *, Matrix *, Matrix *);
00593 
00594 
00595 
00596 <font class="comment">/*</font>
00597 <font class="comment"> * The function is transforming a lattice X in a union of lattices based on a starting lattice Y.</font>
00598 <font class="comment"> * Note1: If the intersection of X and Y lattices is empty the result is identic with the first argument (X) because no operation can be made.</font>
00599 <font class="comment"> *Note2: The function is availabe only for simple Lattices and not for a union of Lattices.</font>
00600 <font class="comment"></font>
00601 <font class="comment"> *       Step 1:  Find Intersection = LatticeIntersection (A, B).</font>
00602 <font class="comment"> *       Step 2:  Extract the Linear Parts of the Lattices A and Intersection.</font>
00603 <font class="comment"> *                (while dealing with Basis we only deal with the Linear Parts)</font>
00604 <font class="comment"> *       Step 3:  Let M1 = Basis of A and M2 = Basis of B.</font>
00605 <font class="comment"> *                Let B1 and B2 be the Basis of A and B respectively, </font>
00606 <font class="comment"> *                corresponding to the above Theorem.</font>
00607 <font class="comment"> *                Then we Have B1 = M1 * U1 {a unimodular Matrix }</font>
00608 <font class="comment"> *                and B2 = M2 * U2. M1 and M2 we know, they are the linear </font>
00609 <font class="comment"> *                parts we obtained in Step 2. Our Task is now to find U1 and</font>
00610 <font class="comment"> *                U2. </font>
00611 <font class="comment"> *                We know that B1  * Delta = B2.</font>
00612 <font class="comment"> *                i.e. M1 * U1 * Delta = M2 * U2</font>
00613 <font class="comment"> *                or U1*Delta*U2Inverse = M1Inverse * M2.</font>
00614 <font class="comment"> *                and Delta is the Diagonal Matrix which satisifies the </font>
00615 <font class="comment"> *                above properties (in the Theorem).</font>
00616 <font class="comment"> *                So Delta is nothing but the Smith Normal Form of </font>
00617 <font class="comment"> *                M1Inverse * M2.</font>
00618 <font class="comment"> *                So, first we have to find M1Inverse.</font>
00619 <font class="comment"> *             </font>
00620 <font class="comment"> *                This Step, involves finding the Inverse of the Matrix M1.</font>
00621 <font class="comment"> *                We find the Inverse using the Polylib function </font>
00622 <font class="comment"> *                Matrix_Inverse. There is a catch here, the result of this</font>
00623 <font class="comment"> *                function is an integral matrix, not necessarily the exact</font>
00624 <font class="comment"> *                Inverse (since M1 need not be Unimodular), but a multiple</font>
00625 <font class="comment"> *                of the actual inverse. The number by which we have to divide</font>
00626 <font class="comment"> *                the matrix, is not obtained here as the input matrix is not</font>
00627 <font class="comment"> *                a Polylib matrix { We input only the Linear part }. Later I</font>
00628 <font class="comment"> *                give a way for finding that number.</font>
00629 <font class="comment"> *</font>
00630 <font class="comment"> *                M1Inverse = Matrix_Inverse ( M1 );</font>
00631 <font class="comment"> *      </font>
00632 <font class="comment"> *      Step 4 :  MtProduct = Matrix_Product (M1Inverse, M2);</font>
00633 <font class="comment"> *      Step 5 :  SmithNormalFrom (MtProduct, Delta, U, V);</font>
00634 <font class="comment"> *                U1 = U and U2Inverse = V.</font>
00635 <font class="comment"> *      Step 6 :  Find U2 = Matrix_Inverse  (U2inverse). Here there is no prob</font>
00636 <font class="comment"> *                as U1 and its inverse are unimodular.</font>
00637 <font class="comment"> *      </font>
00638 <font class="comment"> *      Step 7 :  Compute B1 = M1 * U1;</font>
00639 <font class="comment"> *      Step 8 :  Compute B2 = M2 * U2;</font>
00640 <font class="comment"> *      Step 9 :  Earlier when we computed M1Inverse, we knew that it was not</font>
00641 <font class="comment"> *                the exact inverse but a multiple of it. Now we find the </font>
00642 <font class="comment"> *                number, such that ( M1Inverse / number ) would give us the </font>
00643 <font class="comment"> *                exact inverse of M1.</font>
00644 <font class="comment"> *                We know that B1 * Delta = B2.</font>
00645 <font class="comment"> *                Let k = B2[0][0] / B1[0][0].</font>
00646 <font class="comment"> *                Let number = Delta[0][0]/k;</font>
00647 <font class="comment"> *                This 'number' is the number we want.</font>
00648 <font class="comment"> *                We Divide the matrix Delta by this number, to get the actual</font>
00649 <font class="comment"> *                Delta such that B1 * Delta = B2.</font>
00650 <font class="comment"> *     Step 10 :  Call Split Lattice (B1, B2, Delta ).</font>
00651 <font class="comment"> *                This function returns the Union of Lattices in such a way </font>
00652 <font class="comment"> *                that B2 is at the Head of this List.</font>
00653 <font class="comment"> *</font>
00654 <font class="comment"> *If the intersection between X and Y is empty then the result is NULL.</font>
00655 <font class="comment"> */</font>
00656 
00657 
<a name="l00658"></a><a class="code" href="Lattice_8c.html#a20">00658</a> LatticeUnion *<a class="code" href="Lattice_8c.html#a20">Lattice2LatticeUnion</a>(Lattice *X,Lattice *Y)
00659 {
00660   Lattice *B1 = NULL, *B2 = NULL, *newB1 = NULL, *newB2 = NULL, *Intersection=NULL;
00661   Matrix *U = NULL,*M1 = NULL, *M2 = NULL, *M1Inverse = NULL,*MtProduct = NULL;
00662   Matrix *Vinv, *V , *temp, *DiagMatrix ;
00663 
00664   LatticeUnion *Head = NULL, *tempHead = NULL;
00665   <font class="keywordtype">int</font> i;
00666   <a class="code" href="arithmetique_8h.html#a93">Value</a> k;
00667   
00668 
00669   Intersection = <a class="code" href="Lattice_8c.html#a16">LatticeIntersection</a>(X,Y);
00670   <font class="keywordflow">if</font> (<a class="code" href="Lattice_8c.html#a6">isEmptyLattice</a>(Intersection) == True) {
00671     fprintf(stderr,<font class="stringliteral">"\nIn Lattice2LatticeUnion : The Input Lattices X and Y does not have any common part\n"</font>);
00672     <font class="keywordflow">return</font> NULL;
00673   }  
00674 
00675   <a class="code" href="arithmetique_8h.html#a10">value_init</a>(k);
00676   M1 = (Matrix *)<a class="code" href="Lattice_8c.html#a14">ExtractLinearPart</a>(X);
00677   M2 = (Matrix *)<a class="code" href="Lattice_8c.html#a14">ExtractLinearPart</a>(Intersection);
00678 
00679   M1Inverse = <a class="code" href="matrix_8c.html#a0">Matrix_Alloc</a>(M1-&gt;NbRows,M1-&gt;NbColumns);
00680   temp = <a class="code" href="Matop_8c.html#a5">Matrix_Copy</a>(M1);
00681   <a class="code" href="matrix_8c.html#a13">Matrix_Inverse</a>(temp,M1Inverse);
00682   <a class="code" href="matrix_8c.html#a1">Matrix_Free</a>(temp);
00683 
00684   MtProduct = <a class="code" href="matrix_8c.html#a0">Matrix_Alloc</a>(M1-&gt;NbRows, M1-&gt;NbColumns);
00685   <a class="code" href="matrix_8c.html#a12">Matrix_Product</a>(M1Inverse,M2,MtProduct) ;  
00686   <a class="code" href="NormalForms_8c.html#a15">Smith</a>(MtProduct, &amp;U, &amp;Vinv, &amp;DiagMatrix);  
00687   V = <a class="code" href="matrix_8c.html#a0">Matrix_Alloc</a>(Vinv-&gt;NbRows,Vinv-&gt;NbColumns);
00688   <a class="code" href="matrix_8c.html#a13">Matrix_Inverse</a>(Vinv, V);
00689   <a class="code" href="matrix_8c.html#a1">Matrix_Free</a>(Vinv);  
00690   B1 = <a class="code" href="matrix_8c.html#a0">Matrix_Alloc</a>(M1-&gt;NbRows, U-&gt;NbColumns);
00691   B2 = <a class="code" href="matrix_8c.html#a0">Matrix_Alloc</a>(M2-&gt;NbRows, V-&gt;NbColumns);  
00692   <a class="code" href="matrix_8c.html#a12">Matrix_Product</a>(M1, U, B1);
00693   <a class="code" href="matrix_8c.html#a12">Matrix_Product</a>(M2, V, B2);
00694   <a class="code" href="matrix_8c.html#a1">Matrix_Free</a>(M1);
00695   <a class="code" href="matrix_8c.html#a1">Matrix_Free</a>(M2);  
00696   <a class="code" href="arithmetique_8h.html#a51">value_division</a>(k,B2-&gt;p[0][0],B1-&gt;p[0][0]);
00697   <a class="code" href="arithmetique_8h.html#a51">value_division</a>(k,DiagMatrix-&gt;p[0][0],k);  
00698   <font class="keywordflow">for</font> (i = 0; i &lt; DiagMatrix-&gt;NbRows; i++)
00699     <a class="code" href="arithmetique_8h.html#a51">value_division</a>(DiagMatrix-&gt;p[i][i],DiagMatrix-&gt;p[i][i],k);
00700   newB1 = <a class="code" href="Lattice_8c.html#a13">ChangeLatticeDimension</a>(B1, B1-&gt;NbRows + 1); 
00701   <a class="code" href="matrix_8c.html#a1">Matrix_Free</a>(B1);
00702   newB2 = <a class="code" href="Lattice_8c.html#a13">ChangeLatticeDimension</a>(B2, B2-&gt;NbRows +1);
00703   <a class="code" href="matrix_8c.html#a1">Matrix_Free</a>(B2);  
00704   <font class="keywordflow">for</font>(i = 0; i &lt; newB1-&gt;NbRows - 1;i ++)
00705     <a class="code" href="arithmetique_8h.html#a11">value_assign</a>(newB2-&gt;p[i][newB1-&gt;NbRows-1],Intersection-&gt;p[i][X-&gt;NbRows-1]);
00706   Head = <a class="code" href="Lattice_8c.html#a22">SplitLattice</a>(newB1,newB2,DiagMatrix); 
00707   <a class="code" href="matrix_8c.html#a1">Matrix_Free</a>(newB1);
00708   <a class="code" href="matrix_8c.html#a1">Matrix_Free</a>(DiagMatrix); 
00709   <a class="code" href="arithmetique_8h.html#a14">value_clear</a>(k);
00710   <font class="keywordflow">return</font> Head;
00711 }
00712 
00713 
00714 <font class="comment"></font>
00715 <font class="comment">/**</font>
00716 <font class="comment"></font>
00717 <font class="comment">***        Method : </font>
00718 <font class="comment">***               </font>
00719 <font class="comment">**/</font>
00720 <font class="comment">/* </font>
00721 <font class="comment"> * Return the Union of lattices that constitute the difference the lattices </font>
00722 <font class="comment"> * 'A' and 'B'. The dimensions of 'A' and 'B' should be the same. </font>
00723 <font class="comment"> * Note :</font>
00724 <font class="comment"> *        Inorder to Find the Difference of Lattices, we make use of</font>
00725 <font class="comment"> *        the following facts.</font>
00726 <font class="comment"> *               </font>
00727 <font class="comment"> * Theorem : Given Two Lattices L1 and L2, (L2 subset of L1) there exists a</font>
00728 <font class="comment"> *           Basis B = {b1, b2,..bn} of L1 and integers {a1, a2...,an} such </font>
00729 <font class="comment"> *           that a1 divides a2, a2 divides a3 and so on and {a1b1, a2b2 ,...,</font>
00730 <font class="comment"> *           .., anbn} is a Basis of L2. So given this theorem we can express </font>
00731 <font class="comment"> *           the Lattice L1 in terms of Union of Lattices Involving L2, such </font>
00732 <font class="comment"> *           that Lattice L1 = B1 = Union of (B2 + i1b1 + i2b2 + .. inbn) such</font>
00733 <font class="comment"> *           that 0 &lt;= i1 &lt; a1; 0 &lt;= i2 &lt; a2; .......   0 &lt;= in &lt; an. We also</font>
00734 <font class="comment"> *           know that A/B = A/(A Intersection B) and that (A Intersection B) </font>
00735 <font class="comment"> *           is a subset of A. So, Making use of these two facts, we find the </font>
00736 <font class="comment"> *           A/B. We Split The Lattice A in terms of Lattice (A Int B). From </font>
00737 <font class="comment"> *           this Union of Lattices Delete the Lattice (A Int B).</font>
00738 <font class="comment"> *</font>
00739 <font class="comment"> * Algorithm : </font>
00740 <font class="comment"> *</font>
00741 <font class="comment"> *       Step 1:  Find Intersection = LatticeIntersection (A, B).</font>
00742 <font class="comment"> *       Step 2:  Extract the Linear Parts of the Lattices A and Intersection.</font>
00743 <font class="comment"> *                (while dealing with Basis we only deal with the Linear Parts)</font>
00744 <font class="comment"> *       Step 3:  Let M1 = Basis of A and M2 = Basis of B.</font>
00745 <font class="comment"> *                Let B1 and B2 be the Basis of A and B respectively, </font>
00746 <font class="comment"> *                corresponding to the above Theorem.</font>
00747 <font class="comment"> *                Then we Have B1 = M1 * U1 {a unimodular Matrix }</font>
00748 <font class="comment"> *                and B2 = M2 * U2. M1 and M2 we know, they are the linear </font>
00749 <font class="comment"> *                parts we obtained in Step 2. Our Task is now to find U1 and</font>
00750 <font class="comment"> *                U2. </font>
00751 <font class="comment"> *                We know that B1  * Delta = B2.</font>
00752 <font class="comment"> *                i.e. M1 * U1 * Delta = M2 * U2</font>
00753 <font class="comment"> *                or U1*Delta*U2Inverse = M1Inverse * M2.</font>
00754 <font class="comment"> *                and Delta is the Diagonal Matrix which satisifies the </font>
00755 <font class="comment"> *                above properties (in the Theorem).</font>
00756 <font class="comment"> *                So Delta is nothing but the Smith Normal Form of </font>
00757 <font class="comment"> *                M1Inverse * M2.</font>
00758 <font class="comment"> *                So, first we have to find M1Inverse.</font>
00759 <font class="comment"> *             </font>
00760 <font class="comment"> *                This Step, involves finding the Inverse of the Matrix M1.</font>
00761 <font class="comment"> *                We find the Inverse using the Polylib function </font>
00762 <font class="comment"> *                Matrix_Inverse. There is a catch here, the result of this</font>
00763 <font class="comment"> *                function is an integral matrix, not necessarily the exact</font>
00764 <font class="comment"> *                Inverse (since M1 need not be Unimodular), but a multiple</font>
00765 <font class="comment"> *                of the actual inverse. The number by which we have to divide</font>
00766 <font class="comment"> *                the matrix, is not obtained here as the input matrix is not</font>
00767 <font class="comment"> *                a Polylib matrix { We input only the Linear part }. Later I</font>
00768 <font class="comment"> *                give a way for finding that number.</font>
00769 <font class="comment"> *</font>
00770 <font class="comment"> *                M1Inverse = Matrix_Inverse ( M1 );</font>
00771 <font class="comment"> *      </font>
00772 <font class="comment"> *      Step 4 :  MtProduct = Matrix_Product (M1Inverse, M2);</font>
00773 <font class="comment"> *      Step 5 :  SmithNormalFrom (MtProduct, Delta, U, V);</font>
00774 <font class="comment"> *                U1 = U and U2Inverse = V.</font>
00775 <font class="comment"> *      Step 6 :  Find U2 = Matrix_Inverse  (U2inverse). Here there is no prob</font>
00776 <font class="comment"> *                as U1 and its inverse are unimodular.</font>
00777 <font class="comment"> *      </font>
00778 <font class="comment"> *      Step 7 :  Compute B1 = M1 * U1;</font>
00779 <font class="comment"> *      Step 8 :  Compute B2 = M2 * U2;</font>
00780 <font class="comment"> *      Step 9 :  Earlier when we computed M1Inverse, we knew that it was not</font>
00781 <font class="comment"> *                the exact inverse but a multiple of it. Now we find the </font>
00782 <font class="comment"> *                number, such that ( M1Inverse / number ) would give us the </font>
00783 <font class="comment"> *                exact inverse of M1.</font>
00784 <font class="comment"> *                We know that B1 * Delta = B2.</font>
00785 <font class="comment"> *                Let k = B2[0][0] / B1[0][0].</font>
00786 <font class="comment"> *                Let number = Delta[0][0]/k;</font>
00787 <font class="comment"> *                This 'number' is the number we want.</font>
00788 <font class="comment"> *                We Divide the matrix Delta by this number, to get the actual</font>
00789 <font class="comment"> *                Delta such that B1 * Delta = B2.</font>
00790 <font class="comment"> *     Step 10 :  Call Split Lattice (B1, B2, Delta ).</font>
00791 <font class="comment"> *                This function returns the Union of Lattices in such a way </font>
00792 <font class="comment"> *                that B2 is at the Head of this List.</font>
00793 <font class="comment"> *     Step 11 :  To Remove B2 From the list of the Union of Lattices.</font>
00794 <font class="comment"> *                Head = Head-&gt;next;</font>
00795 <font class="comment"> *     Step 12 :  Free the Memory that is now not needed and return Head.</font>
00796 <font class="comment"> *</font>
00797 <font class="comment"> */</font>
<a name="l00798"></a><a class="code" href="Lattice_8c.html#a21">00798</a> LatticeUnion *<a class="code" href="Lattice_8c.html#a21">LatticeDifference</a>(Lattice  *A,Lattice *B) {
00799  
00800   Lattice *Intersection = NULL;
00801   LatticeUnion *Head = NULL, *tempHead = NULL;
00802   Matrix *H , *U1 , *X, *Y ;
00803 
00804 <font class="preprocessor">#ifdef DOMDEBUG</font>
00805 <font class="preprocessor"></font>  FILE *fp;
00806   fp = fopen(<font class="stringliteral">"_debug"</font>, <font class="stringliteral">"a"</font>);
00807   fprintf(fp,<font class="stringliteral">"\nEntered LATTICEDIFFERENCE \n"</font>); 
00808   fclose(fp);
00809 <font class="preprocessor">#endif</font>
00810 <font class="preprocessor"></font>
00811   <font class="keywordflow">if</font> (A-&gt;NbRows != A-&gt;NbColumns) { 
00812     fprintf(stderr,<font class="stringliteral">"\nIn LatticeDifference : The Input Matrix A is not a proper Lattice \n"</font>);
00813     <font class="keywordflow">return</font> NULL;
00814   }
00815   
00816   <font class="keywordflow">if</font> (B-&gt;NbRows != B-&gt;NbColumns) { 
00817     fprintf(stderr,<font class="stringliteral">"\nIn LatticeDifference : The Input Matrix B is not a proper Lattice \n"</font>);
00818     <font class="keywordflow">return</font> NULL;
00819   }
00820   
00821   <font class="keywordflow">if</font> (A-&gt;NbRows != B-&gt;NbRows) {
00822     fprintf(stderr,<font class="stringliteral">"\nIn Lattice Difference : The Input Lattices A and B have "</font>);
00823     fprintf(stderr,<font class="stringliteral">"incompatible dimensions \n"</font>);
00824     <font class="keywordflow">return</font> NULL;
00825   }
00826 
00827 <font class="keywordflow">if</font> (<a class="code" href="Matop_8c.html#a7">isinHnf</a> (A) != True) {
00828     <a class="code" href="Lattice_8c.html#a8">AffineHermite</a>(A,&amp;H,&amp;U1);
00829     X = <a class="code" href="Matop_8c.html#a5">Matrix_Copy</a>(H);    
00830     <a class="code" href="matrix_8c.html#a1">Matrix_Free</a>(U1);
00831     <a class="code" href="matrix_8c.html#a1">Matrix_Free</a>(H);
00832   }
00833   <font class="keywordflow">else</font>
00834     X = <a class="code" href="Matop_8c.html#a5">Matrix_Copy</a>(A);
00835   
00836   <font class="keywordflow">if</font> (<a class="code" href="Matop_8c.html#a7">isinHnf</a>(B) != True) {
00837     <a class="code" href="Lattice_8c.html#a8">AffineHermite</a>(B,&amp;H,&amp;U1);
00838     Y = <a class="code" href="Matop_8c.html#a5">Matrix_Copy</a>(H);   
00839     <a class="code" href="matrix_8c.html#a1">Matrix_Free</a>(H);
00840     <a class="code" href="matrix_8c.html#a1">Matrix_Free</a>(U1);
00841   }
00842   <font class="keywordflow">else</font>
00843     Y = <a class="code" href="Matop_8c.html#a5">Matrix_Copy</a>(B);  
00844   <font class="keywordflow">if</font> (<a class="code" href="Lattice_8c.html#a6">isEmptyLattice</a>(X)) {
00845     <font class="keywordflow">return</font> NULL;  
00846   } 
00847 
00848   Head=<a class="code" href="Lattice_8c.html#a20">Lattice2LatticeUnion</a>(X,Y);
00849 
00850 <font class="comment">/* If the spliting operation can't be done the result is X. */</font>
00851 
00852   <font class="keywordflow">if</font> (Head == NULL) {
00853     Head = (LatticeUnion *)malloc(<font class="keyword">sizeof</font>(LatticeUnion));
00854     Head-&gt;M = <a class="code" href="Matop_8c.html#a5">Matrix_Copy</a>(X);
00855     Head-&gt;next = NULL;
00856     <a class="code" href="matrix_8c.html#a1">Matrix_Free</a>(X);
00857     <a class="code" href="matrix_8c.html#a1">Matrix_Free</a>(Y);
00858     <font class="keywordflow">return</font> Head;
00859   } 
00860 
00861   tempHead = Head;
00862   Head = Head-&gt;next;  
00863   <a class="code" href="matrix_8c.html#a1">Matrix_Free</a> (tempHead-&gt;M);
00864   tempHead-&gt;next = NULL; 
00865   free(tempHead);  
00866 
00867   <font class="keywordflow">if</font> ((Head != NULL))
00868     Head = <a class="code" href="Lattice_8c.html#a36">LatticeSimplify</a> (Head);
00869   <a class="code" href="matrix_8c.html#a1">Matrix_Free</a> (X);
00870   <a class="code" href="matrix_8c.html#a1">Matrix_Free</a> (Y); 
00871 
00872   <font class="keywordflow">return</font> Head;
00873 } <font class="comment">/* LatticeDifference */</font>
00874 
00875 
00876 <font class="comment">/*</font>
00877 <font class="comment"> * Given a Lattice 'B1' and a Lattice 'B2' and a Diagonal Matrix 'C' such that</font>
00878 <font class="comment"> * 'B2' is a subset of 'B1' and C[0][0] divides C[1][1], C[1][1] divides C[2]</font>
00879 <font class="comment"> * [2] and so on, output the list of matrices whose union is B1. The function</font>
00880 <font class="comment"> * expresses the Lattice B1 in terms of B2 Unions of B1 = Union of {B2 + i0b0 +</font>
00881 <font class="comment"> * i1b1 + .... + inbn} where 0 &lt;= i0 &lt; C[0][0]; 0 &lt;= i1 &lt; C[1][1] and so on and</font>
00882 <font class="comment"> * {b0 ... bn} are the columns of Lattice B1. The list is so formed that the </font>
00883 <font class="comment"> * Lattice B2 is the Head of the list. </font>
00884 <font class="comment"> */</font>     
<a name="l00885"></a><a class="code" href="Lattice_8c.html#a22">00885</a> LatticeUnion *<a class="code" href="Lattice_8c.html#a22">SplitLattice</a>(Lattice *B1, Lattice *B2, Matrix *C) {
00886   
00887   <font class="keywordtype">int</font> i;
00888   
00889   LatticeUnion *Head = NULL;  
00890   Head = (LatticeUnion *)malloc(<font class="keyword">sizeof</font>(LatticeUnion));
00891   Head-&gt;M = (Lattice *)B2;
00892   Head-&gt;next = NULL;  
00893   <font class="keywordflow">for</font> (i = 0; i &lt; C-&gt;NbRows ; i++)
00894     <a class="code" href="Lattice_8c.html#a18">AddLattice</a>(Head,B1,B2,<a class="code" href="arithmetique_8h.html#a7">VALUE_TO_INT</a>(C-&gt;p[i][i]),i);  
00895   <font class="keywordflow">return</font> Head;
00896 } <font class="comment">/* SplitLattice */</font>
00897 
00898 <font class="comment">/*</font>
00899 <font class="comment"> * Given lattices 'B1' and 'B2', an integer 'NumofTimes', a column number </font>
00900 <font class="comment"> * 'Colnumber' and a pointer to a list of lattices, the function does the </font>
00901 <font class="comment"> * following :-</font>
00902 <font class="comment"> * For every lattice in the list, it adds a set of lattices such that the </font>
00903 <font class="comment"> * affine part of the new lattices is greater than the original lattice by 0 to</font>
00904 <font class="comment"> * NumofTimes-1 * {the (ColumnNumber)-th column of B1}. </font>
00905 <font class="comment"> * Note : </font>
00906 <font class="comment"> * Three pointers are defined to point at various points of the list. They are:</font>
00907 <font class="comment"> * Head   -&gt; It always points to the head of the list. </font>
00908 <font class="comment"> * tail   -&gt; It always points to the last element in the list. </font>
00909 <font class="comment"> * marker -&gt; It points to the element, which is the last element of the Input </font>
00910 <font class="comment"> *           list.</font>
00911 <font class="comment"> */</font> 
<a name="l00912"></a><a class="code" href="Lattice_8c.html#a18">00912</a> <font class="keyword">static</font> <font class="keywordtype">void</font> <a class="code" href="Lattice_8c.html#a18">AddLattice</a> (LatticeUnion *Head, Matrix  *B1,  Matrix *B2, <font class="keywordtype">int</font> NumofTimes, <font class="keywordtype">int</font> Colnumber) {
00913   
00914   LatticeUnion *temp, *tail, *marker;
00915   <font class="keywordtype">int</font> i,j;
00916   <a class="code" href="arithmetique_8h.html#a93">Value</a> tmp;
00917   
00918   <a class="code" href="arithmetique_8h.html#a10">value_init</a>(tmp);
00919   tail =  Head;  
00920   <font class="keywordflow">while</font> (tail-&gt;next != NULL)
00921     tail = tail-&gt;next;  
00922   marker = tail;
00923   
00924   <font class="keywordflow">for</font>(temp = Head; temp != NULL; temp=temp-&gt;next) {
00925     <font class="keywordflow">for</font> (i = 1; i &lt; NumofTimes; i++) { 
00926       Lattice *tempMatrix, *H, *U;
00927       
00928       tempMatrix = (Lattice *)<a class="code" href="Matop_8c.html#a5">Matrix_Copy</a>(temp-&gt;M);       
00929       <font class="keywordflow">for</font> (j = 0; j &lt; B2-&gt;NbRows; j++) {
00930         <a class="code" href="arithmetique_8h.html#a12">value_set_si</a>(tmp,i);
00931         <a class="code" href="arithmetique_8h.html#a47">value_multiply</a>(tmp,tmp,B1-&gt;p[j][Colnumber]);
00932         <a class="code" href="arithmetique_8h.html#a43">value_addto</a>(tempMatrix-&gt;p[j][B2-&gt;NbColumns-1],tempMatrix-&gt;p[j][B2-&gt;NbColumns-1],tmp);   
00933       }
00934       tail-&gt;next = (LatticeUnion *)malloc(<font class="keyword">sizeof</font>(LatticeUnion)); 
00935       <a class="code" href="Lattice_8c.html#a8">AffineHermite</a>(tempMatrix,&amp;H,&amp;U);
00936       <a class="code" href="matrix_8c.html#a1">Matrix_Free</a>((Matrix *)tempMatrix);
00937       <a class="code" href="matrix_8c.html#a1">Matrix_Free</a>(U);
00938       tail-&gt;next-&gt;M = H;
00939       tail-&gt;next-&gt;next=NULL;
00940       tail = tail-&gt;next;
00941     }
00942     <font class="keywordflow">if</font> (temp == marker)
00943       <font class="keywordflow">break</font>;
00944   }  
00945   <a class="code" href="arithmetique_8h.html#a14">value_clear</a>(tmp);
00946   <font class="keywordflow">return</font>;
00947 } <font class="comment">/* AddLattice */</font>
00948 
00949 <font class="comment">/* </font>
00950 <font class="comment"> * Given a polyhedron 'A', store the Hermite basis 'B' and return the true </font>
00951 <font class="comment"> * dimension of the polyhedron 'A'. </font>
00952 <font class="comment"> * Algorithm : </font>
00953 <font class="comment"> *</font>
00954 <font class="comment"> *             1) First we find all the vertices of the Polyhedron A.</font>
00955 <font class="comment"> *                Now suppose the vertices are [v1, v2...vn], then </font>
00956 <font class="comment"> *                a particular set of vectors governing the space of A are </font>
00957 <font class="comment"> *                given by [v1-v2, v1-v3, ... v1-vn] (let us say V).</font>
00958 <font class="comment"> *                So we initially calculate these vectors.</font>
00959 <font class="comment"> *             2) Then there are the rays and lines which contribute to the</font>
00960 <font class="comment"> *                space in which A is going to lie.</font>
00961 <font class="comment"> *                So we append to the rays and lines. So now we get a matrix</font>
00962 <font class="comment"> *                {These are the rows} [ V ] [l1] [l2]...[lk] </font>
00963 <font class="comment"> *                where l1 to lk are either rays or lines of the Polyhedron A.</font>
00964 <font class="comment"> *             3) The above matrix is the set of vectors which determine</font>
00965 <font class="comment"> *                the space in which A is going to lie.</font>
00966 <font class="comment"> *                Using this matrix we find a Basis which is such that</font>
00967 <font class="comment"> *                the first 'm' columns of it determine the space of A. </font>
00968 <font class="comment"> *             4) But we also have to ensure that in the last 'n-m' </font>
00969 <font class="comment"> *                coordinates the Polyhedron is '0', this is done by</font>
00970 <font class="comment"> *                taking the image by B(inv) of A and finding the remaining</font>
00971 <font class="comment"> *                equalities, and composing it with the matrix B, so as</font>
00972 <font class="comment"> *                to get a new matrix which is the actual Hermite Basis of</font>
00973 <font class="comment"> *                the Polyhedron.</font>
00974 <font class="comment"> */</font>
<a name="l00975"></a><a class="code" href="Lattice_8c.html#a23">00975</a> <font class="keywordtype">int</font> <a class="code" href="Lattice_8c.html#a23">FindHermiteBasisofDomain</a>(Polyhedron *A, Matrix **B) {
00976   
00977   <font class="keywordtype">int</font> i, j;
00978   Matrix *temp,*temp1, *tempinv, *Newmat ;
00979   Matrix *vert, *rays, *result;
00980   Polyhedron *Image;
00981   <font class="keywordtype">int</font> rank, equcount ;
00982   <font class="keywordtype">int</font> noofvertices = 0, noofrays = 0;
00983   <font class="keywordtype">int</font> vercount , raycount;
00984   <a class="code" href="arithmetique_8h.html#a93">Value</a> lcm, fact;
00985   
00986 <font class="preprocessor">#ifdef DOMDEBUG</font>
00987 <font class="preprocessor"></font>  FILE *fp;
00988   fp = fopen(<font class="stringliteral">"_debug"</font>, <font class="stringliteral">"a"</font>);
00989   fprintf(fp,<font class="stringliteral">"\nEntered FINDHERMITEBASISOFDOMAIN \n"</font>); 
00990   fclose(fp);
00991 <font class="preprocessor">#endif</font>
00992 <font class="preprocessor"></font>  
00993   <font class="comment">/* Checking is empty */</font>  
00994   <font class="keywordflow">if</font> (emptyQ(A)) {
00995       B[0] = <a class="code" href="Matop_8c.html#a1">Identity</a>(A-&gt;Dimension+1);
00996       <font class="keywordflow">return</font>(-1);
00997    }
00998 
00999   <a class="code" href="arithmetique_8h.html#a10">value_init</a>(lcm); <a class="code" href="arithmetique_8h.html#a10">value_init</a>(fact);
01000   <a class="code" href="arithmetique_8h.html#a12">value_set_si</a>(lcm,1);
01001 
01002   <font class="comment">/* Finding the Vertices */</font>  
01003   <font class="keywordflow">for</font> (i = 0; i &lt; A-&gt;NbRays; i++)
01004     <font class="keywordflow">if</font> ((<a class="code" href="arithmetique_8h.html#a68">value_notzero_p</a>(A-&gt;Ray[i][0])) &amp;&amp; <a class="code" href="arithmetique_8h.html#a68">value_notzero_p</a>(A-&gt;Ray[i][A-&gt;Dimension+1]))
01005       noofvertices++;
01006     <font class="keywordflow">else</font> 
01007       noofrays ++;
01008   
01009   vert = <a class="code" href="matrix_8c.html#a0">Matrix_Alloc</a>(noofvertices,A-&gt;Dimension+1);
01010   rays = <a class="code" href="matrix_8c.html#a0">Matrix_Alloc</a>(noofrays,A-&gt;Dimension);
01011   vercount = 0;
01012   raycount = 0;
01013   
01014   <font class="keywordflow">for</font>(i = 0; i &lt; A-&gt;NbRays; i++) {
01015     <font class="keywordflow">if</font> ((<a class="code" href="arithmetique_8h.html#a68">value_notzero_p</a>(A-&gt;Ray[i][0])) &amp;&amp; <a class="code" href="arithmetique_8h.html#a68">value_notzero_p</a>(A-&gt;Ray[i][A-&gt;Dimension+1])) {
01016       <font class="keywordflow">for</font>(j = 1; j &lt; A-&gt;Dimension+2; j++) 
01017         <a class="code" href="arithmetique_8h.html#a11">value_assign</a>(vert-&gt;p[vercount][j-1],A-&gt;Ray[i][j]);
01018       <a class="code" href="arithmetique_8h.html#a11">value_assign</a>(lcm,*<a class="code" href="Matop_8c.html#a0">Lcm</a>(lcm,A-&gt;Ray[i][j-1]));
01019       vercount++;
01020     }
01021     <font class="keywordflow">else</font> {
01022       <font class="keywordflow">for</font> (j = 1; j &lt; A-&gt;Dimension+1; j++)
01023         <a class="code" href="arithmetique_8h.html#a11">value_assign</a>(rays-&gt;p[raycount][j-1],A-&gt;Ray[i][j]);
01024       raycount++;       
01025     }
01026   }
01027   
01028   <font class="comment">/* Multiplying the rows by the lcm */</font>
01029   <font class="keywordflow">for</font>(i = 0; i &lt; vert-&gt;NbRows; i ++) {    
01030     <a class="code" href="arithmetique_8h.html#a51">value_division</a>(fact,lcm,vert-&gt;p[i][vert-&gt;NbColumns-1]);
01031     <font class="keywordflow">for</font> (j = 0; j &lt; vert-&gt;NbColumns-1; j++)
01032       <a class="code" href="arithmetique_8h.html#a47">value_multiply</a>(vert-&gt;p[i][j],vert-&gt;p[i][j],fact);
01033   }
01034   
01035   <font class="comment">/* Drop the Last Columns */</font>
01036   temp = <a class="code" href="Matop_8c.html#a15">RemoveColumn</a>(vert,vert-&gt;NbColumns-1);
01037   <a class="code" href="matrix_8c.html#a1">Matrix_Free</a>(vert);
01038   
01039   <font class="comment">/* Getting the Vectors */</font>
01040   vert = <a class="code" href="matrix_8c.html#a0">Matrix_Alloc</a>(temp-&gt;NbRows-1, temp-&gt;NbColumns);
01041   <font class="keywordflow">for</font> (i = 1; i &lt; temp-&gt;NbRows; i++)
01042     <font class="keywordflow">for</font> (j = 0; j &lt; temp-&gt;NbColumns ; j++)
01043       <a class="code" href="arithmetique_8h.html#a48">value_substract</a>(vert-&gt;p[i-1][j],temp-&gt;p[0][j],temp-&gt;p[i][j]);
01044   
01045   <font class="comment">/* Add the Rays and Lines */</font>
01046   <font class="comment">/* Combined Matrix */</font>  
01047   result = <a class="code" href="matrix_8c.html#a0">Matrix_Alloc</a>(vert-&gt;NbRows+rays-&gt;NbRows, vert-&gt;NbColumns);
01048   <font class="keywordflow">for</font> (i = 0; i &lt; vert-&gt;NbRows; i++)
01049     <font class="keywordflow">for</font> (j = 0 ;j &lt; result-&gt;NbColumns ; j++)
01050       <a class="code" href="arithmetique_8h.html#a11">value_assign</a>(result-&gt;p[i][j],vert-&gt;p[i][j]);
01051   
01052   <font class="keywordflow">for</font> (; i&lt;result-&gt;NbRows; i++)
01053     <font class="keywordflow">for</font> (j = 0; j &lt; result-&gt;NbColumns; j++)
01054       <a class="code" href="arithmetique_8h.html#a11">value_assign</a>(result-&gt;p[i][j],rays-&gt;p[i-vert-&gt;NbRows][j]);
01055 
01056 <font class="comment">//  printf("\nIn FHB:-\n");</font>
01057 <font class="comment">//  Matrix_Print(stdout,P_VALUE_FMT, result);</font>
01058 
01059   rank = <a class="code" href="Matop_8c.html#a16">findHermiteBasis</a>(result, &amp;temp);
01060   temp1 = <a class="code" href="Lattice_8c.html#a13">ChangeLatticeDimension</a>(temp,temp-&gt;NbRows+1);
01061 
01062   <font class="comment">//  printf("\nThe rank of the Domain is %d\n", rank);</font>
01063   <font class="comment">//  Matrix_Print(stdout,P_VALUE_FMT,temp1);</font>
01064   <a class="code" href="matrix_8c.html#a1">Matrix_Free</a>(temp);
01065   
01066   <font class="comment">/* Adding the Affine Part to take care of the Equalities */</font>  
01067   temp = <a class="code" href="Matop_8c.html#a5">Matrix_Copy</a>(temp1);
01068   tempinv = <a class="code" href="matrix_8c.html#a0">Matrix_Alloc</a>(temp-&gt;NbRows,temp-&gt;NbColumns);
01069   <a class="code" href="matrix_8c.html#a13">Matrix_Inverse</a>(temp,tempinv); 
01070   <a class="code" href="matrix_8c.html#a1">Matrix_Free</a>(temp);
01071   Image = <a class="code" href="polyhedron_8c.html#a53">DomainImage</a>(A,tempinv,MAXNOOFRAYS);  
01072   Newmat = <a class="code" href="matrix_8c.html#a0">Matrix_Alloc</a>(temp1-&gt;NbRows,temp1-&gt;NbColumns);
01073   <font class="keywordflow">for</font>(i = 0; i &lt; rank ; i++)
01074     <font class="keywordflow">for</font>(j = 0; j &lt; Newmat-&gt;NbColumns ; j++) 
01075       <a class="code" href="arithmetique_8h.html#a12">value_set_si</a>(Newmat-&gt;p[i][j],0);  
01076   <font class="keywordflow">for</font>(i = 0; i &lt; rank; i++)
01077     <a class="code" href="arithmetique_8h.html#a12">value_set_si</a>(Newmat-&gt;p[i][i],1);  
01078   equcount = 0;  
01079   <font class="keywordflow">for</font> (i = 0; i &lt; Image-&gt;NbConstraints; i ++)
01080     <font class="keywordflow">if</font> (<a class="code" href="arithmetique_8h.html#a67">value_zero_p</a>(Image-&gt;Constraint[i][0])) {
01081       <font class="keywordflow">for</font> (j = 1; j&lt;Image-&gt;Dimension+2; j ++)
01082         <a class="code" href="arithmetique_8h.html#a11">value_assign</a>(Newmat-&gt;p[rank+equcount][j-1],Image-&gt;Constraint[i][j]);
01083       ++equcount ;
01084     } 
01085   <font class="keywordflow">for</font> (i = 0; i &lt; Newmat-&gt;NbColumns-1; i++)
01086     <a class="code" href="arithmetique_8h.html#a12">value_set_si</a>(Newmat-&gt;p[Newmat-&gt;NbRows-1][i],0);
01087   <a class="code" href="arithmetique_8h.html#a12">value_set_si</a>(Newmat-&gt;p[Newmat-&gt;NbRows-1][Newmat-&gt;NbColumns-1],1);
01088   temp = <a class="code" href="matrix_8c.html#a0">Matrix_Alloc</a>(Newmat-&gt;NbRows, Newmat-&gt;NbColumns);
01089   <a class="code" href="matrix_8c.html#a13">Matrix_Inverse</a>(Newmat,temp);
01090   B[0] = <a class="code" href="matrix_8c.html#a0">Matrix_Alloc</a>(temp1-&gt;NbRows,temp-&gt;NbColumns);
01091 
01092 <font class="comment">//  Matrix_Print (stdout,P_VALUE_FMT,temp);</font>
01093   
01094   <a class="code" href="matrix_8c.html#a12">Matrix_Product</a>(temp1,temp,B[0]);  
01095   <a class="code" href="arithmetique_8h.html#a14">value_clear</a>(lcm);
01096   <a class="code" href="arithmetique_8h.html#a14">value_clear</a>(fact);
01097   <font class="keywordflow">return</font> rank;
01098 } <font class="comment">/* FindHermiteBasisofDomain */</font> 
01099 
01100 <font class="comment">/*</font>
01101 <font class="comment"> * Return the image of a lattice 'A' by the invertible, affine, rational </font>
01102 <font class="comment"> * function 'M'. </font>
01103 <font class="comment"> */</font>
<a name="l01104"></a><a class="code" href="Lattice_8c.html#a24">01104</a> Lattice *<a class="code" href="Lattice_8c.html#a24">LatticeImage</a>(Lattice *A, Matrix *M) {
01105  
01106   Lattice *Img, *temp, *Minv;
01107 
01108 <font class="preprocessor">#ifdef DOMDEBUG</font>
01109 <font class="preprocessor"></font>  FILE *fp;
01110   fp = fopen(<font class="stringliteral">"_debug"</font>, <font class="stringliteral">"a"</font>);
01111   fprintf(fp, <font class="stringliteral">"\nEntered LATTICEIMAGE \n"</font>); 
01112   fclose(fp);
01113 <font class="preprocessor">#endif</font>
01114 <font class="preprocessor"></font>
01115   <font class="keywordflow">if</font> ((A-&gt;NbRows != M-&gt;NbRows) || (M-&gt;NbRows != M-&gt;NbColumns))
01116     <font class="keywordflow">return</font> (<a class="code" href="Lattice_8c.html#a5">EmptyLattice</a> (A-&gt;NbRows));
01117   
01118   <font class="keywordflow">if</font> (<a class="code" href="arithmetique_8h.html#a69">value_one_p</a>(M-&gt;p[M-&gt;NbRows-1][M-&gt;NbColumns-1])) {
01119     Img = <a class="code" href="matrix_8c.html#a0">Matrix_Alloc</a> ( M-&gt;NbRows, A-&gt;NbColumns );
01120     <a class="code" href="matrix_8c.html#a12">Matrix_Product</a> (M,A,Img);
01121     <font class="keywordflow">return</font> Img;
01122   } 
01123   temp = <a class="code" href="Matop_8c.html#a5">Matrix_Copy</a>(M);
01124   Minv = <a class="code" href="matrix_8c.html#a0">Matrix_Alloc</a>(temp-&gt;NbColumns, temp-&gt;NbRows);
01125   <a class="code" href="matrix_8c.html#a13">Matrix_Inverse</a>(temp, Minv);
01126   <a class="code" href="matrix_8c.html#a1">Matrix_Free</a>(temp);
01127   
01128   Img = <a class="code" href="Lattice_8c.html#a25">LatticePreimage</a>(A, Minv);
01129   <a class="code" href="matrix_8c.html#a1">Matrix_Free</a> (Minv);
01130   <font class="keywordflow">return</font> Img;
01131 } <font class="comment">/* LatticeImage */</font>
01132 
01133 <font class="comment">/* </font>
01134 <font class="comment"> * Return the preimage of a lattice 'L' by an affine, rational function 'G'.</font>
01135 <font class="comment"> * Algorithm: </font>
01136 <font class="comment"> *           (1) Prepare Diophantine equation :</font>
01137 <font class="comment"> *               [Gl -Ll][x y] = [Ga -La]{"l-linear, a-affine"}</font>
01138 <font class="comment"> *           (2) Solve the Diophantine equations.</font>
01139 <font class="comment"> *           (3) If there is solution to the Diophantine eq., extract the </font>
01140 <font class="comment"> *               general solution and the particular solution of x and that </font>
01141 <font class="comment"> *               forms the preimage of 'L' by 'G'. </font>
01142 <font class="comment"> */</font>
<a name="l01143"></a><a class="code" href="Lattice_8c.html#a25">01143</a> Lattice *<a class="code" href="Lattice_8c.html#a25">LatticePreimage</a>(Lattice *L, Matrix *G) {
01144  
01145   Matrix *Dio, *U ;
01146   Lattice *Result;
01147   Vector *X;
01148   <font class="keywordtype">int</font> i,j;
01149   <font class="keywordtype">int</font> rank;
01150   <a class="code" href="arithmetique_8h.html#a93">Value</a> divisor, tmp;
01151   
01152 <font class="preprocessor">#ifdef DOMDEBUG</font>
01153 <font class="preprocessor"></font>  FILE *fp;
01154   fp = fopen(<font class="stringliteral">"_debug"</font>, <font class="stringliteral">"a"</font>);
01155   fprintf(fp,<font class="stringliteral">"\nEntered LATTICEPREIMAGE \n"</font>); 
01156   fclose(fp);
01157 <font class="preprocessor">#endif</font>
01158 <font class="preprocessor"></font>  
01159   <font class="comment">/* Check for the validity of the function */</font>  
01160   <font class="keywordflow">if</font> (G-&gt;NbRows != L-&gt;NbRows) {
01161     fprintf (stderr, <font class="stringliteral">"\nIn LatticePreimage: Incompatible types of Lattice and the function\n"</font>);
01162     <font class="keywordflow">return</font> (<a class="code" href="Lattice_8c.html#a5">EmptyLattice</a>(G-&gt;NbColumns));
01163   }
01164   
01165   <a class="code" href="arithmetique_8h.html#a10">value_init</a>(divisor); <a class="code" href="arithmetique_8h.html#a10">value_init</a>(tmp);
01166   
01167   <font class="comment">/* Making Diophantine Equations [g -L] */</font>
01168   <a class="code" href="arithmetique_8h.html#a11">value_assign</a>(divisor,G-&gt;p[G-&gt;NbRows-1][G-&gt;NbColumns-1]);
01169   Dio = <a class="code" href="matrix_8c.html#a0">Matrix_Alloc</a>(G-&gt;NbRows, G-&gt;NbColumns+L-&gt;NbColumns-1);
01170   <font class="keywordflow">for</font> (i = 0; i &lt; G-&gt;NbRows-1; i++)
01171     <font class="keywordflow">for</font> (j = 0; j &lt; G-&gt;NbColumns-1; j++)
01172       <a class="code" href="arithmetique_8h.html#a11">value_assign</a>(Dio-&gt;p[i][j],G-&gt;p[i][j]);
01173   
01174   <font class="keywordflow">for</font> (i = 0;i &lt; G-&gt;NbRows-1; i++)
01175     <font class="keywordflow">for</font> (j = 0; j &lt; L-&gt;NbColumns-1; j++) {
01176       <a class="code" href="arithmetique_8h.html#a47">value_multiply</a>(tmp,divisor,L-&gt;p[i][j]);
01177       <a class="code" href="arithmetique_8h.html#a54">value_oppose</a>(Dio-&gt;p[i][j+G-&gt;NbColumns-1],tmp);
01178     }
01179   
01180   <font class="keywordflow">for</font> (i = 0; i &lt; Dio-&gt;NbRows-1; i++) {
01181     <a class="code" href="arithmetique_8h.html#a47">value_multiply</a>(tmp,divisor,L-&gt;p[i][L-&gt;NbColumns-1]);
01182     <a class="code" href="arithmetique_8h.html#a48">value_substract</a>(tmp,G-&gt;p[i][G-&gt;NbColumns-1],tmp);
01183     <a class="code" href="arithmetique_8h.html#a11">value_assign</a>(Dio-&gt;p[i][Dio-&gt;NbColumns-1],tmp);
01184   }
01185   <font class="keywordflow">for</font> (i = 0; i &lt; Dio-&gt;NbColumns-1; i++)
01186     <a class="code" href="arithmetique_8h.html#a12">value_set_si</a>(Dio-&gt;p[Dio-&gt;NbRows-1][i],0);
01187   
01188   <a class="code" href="arithmetique_8h.html#a12">value_set_si</a>(Dio-&gt;p[Dio-&gt;NbRows-1][Dio-&gt;NbColumns-1],1); 
01189   rank = <a class="code" href="SolveDio_8c.html#a1">SolveDiophantine</a>(Dio, &amp;U, &amp;X);
01190   
01191   <font class="keywordflow">if</font> (rank == -1)
01192     Result = <a class="code" href="Lattice_8c.html#a5">EmptyLattice</a>(G-&gt;NbColumns);
01193   <font class="keywordflow">else</font> {
01194     Result = <a class="code" href="matrix_8c.html#a0">Matrix_Alloc</a> (G-&gt;NbColumns, G-&gt;NbColumns);
01195     <font class="keywordflow">for</font> (i = 0; i &lt; Result-&gt;NbRows-1; i++)
01196       <font class="keywordflow">for</font> (j = 0; j &lt; Result-&gt;NbColumns-1; j++)
01197         <a class="code" href="arithmetique_8h.html#a11">value_assign</a>(Result-&gt;p[i][j],U-&gt;p[i][j]);
01198     
01199     <font class="keywordflow">for</font> (i = 0; i &lt; Result-&gt;NbRows-1; i ++)
01200       <a class="code" href="arithmetique_8h.html#a11">value_assign</a>(Result-&gt;p[i][Result-&gt;NbColumns-1],X-&gt;p[i]);  
01201     <a class="code" href="matrix_8c.html#a1">Matrix_Free</a> (U);
01202     <a class="code" href="vector_8c.html#a6">Vector_Free</a> (X);   
01203     <font class="keywordflow">for</font> (i = 0; i &lt; Result-&gt;NbColumns-1; i ++)
01204       <a class="code" href="arithmetique_8h.html#a12">value_set_si</a>(Result-&gt;p[Result-&gt;NbRows-1][i],0);
01205     <a class="code" href="arithmetique_8h.html#a12">value_set_si</a>(Result-&gt;p[i][i],1);
01206   } 
01207   <a class="code" href="matrix_8c.html#a1">Matrix_Free</a>(Dio);
01208   <a class="code" href="arithmetique_8h.html#a14">value_clear</a>(divisor);
01209   <a class="code" href="arithmetique_8h.html#a14">value_clear</a>(tmp);
01210   <font class="keywordflow">return</font> Result;
01211 } <font class="comment">/* LatticePreimage */</font>
01212  
01213 <font class="comment">/*</font>
01214 <font class="comment"> * Return True if the matrix 'm' is a valid lattice, otherwise return False. </font>
01215 <font class="comment"> * Note: A valid lattice has the last row as [0 0 0 ... 1]. </font>
01216 <font class="comment"> */</font> 
<a name="l01217"></a><a class="code" href="Lattice_8c.html#a26">01217</a> Bool <a class="code" href="Lattice_8c.html#a26">IsLattice</a>(Matrix *m) {
01218   
01219   <font class="keywordtype">int</font> i;
01220   
01221 <font class="preprocessor">#ifdef DOMDEBUG</font>
01222 <font class="preprocessor"></font>  FILE *fp;
01223   fp = fopen (<font class="stringliteral">"_debug"</font>, <font class="stringliteral">"a"</font>);
01224   fprintf (fp, <font class="stringliteral">"\nEntered ISLATTICE \n"</font>); 
01225   fclose (fp);
01226 <font class="preprocessor">#endif</font>
01227 <font class="preprocessor"></font>  
01228   <font class="comment">/* Is it necessary to check if the lattice</font>
01229 <font class="comment">     is fulldimensional or not here only? */</font>
01230   
01231   <font class="keywordflow">if</font> (m-&gt;NbRows != m-&gt;NbColumns)
01232     <font class="keywordflow">return</font> False;
01233   
01234   <font class="keywordflow">for</font> (i = 0; i &lt; m-&gt;NbColumns-1; i++)
01235     <font class="keywordflow">if</font> (<a class="code" href="arithmetique_8h.html#a68">value_notzero_p</a>(m-&gt;p[m-&gt;NbRows-1][i])) 
01236       <font class="keywordflow">return</font> False ;
01237   <font class="keywordflow">if</font> (<a class="code" href="arithmetique_8h.html#a70">value_notone_p</a>(m-&gt;p[i][i])) 
01238     <font class="keywordflow">return</font> False;
01239   <font class="keywordflow">return</font> True ;
01240 } <font class="comment">/* IsLattice */</font> 
01241  
01242 <font class="comment">/*</font>
01243 <font class="comment"> *  Check whether the matrix 'm' is full row-rank or not. </font>
01244 <font class="comment"> */</font> 
<a name="l01245"></a><a class="code" href="Lattice_8c.html#a27">01245</a> Bool <a class="code" href="Lattice_8c.html#a27">isfulldim</a>(Matrix *m) {
01246   
01247   Matrix *h, *u ;
01248   <font class="keywordtype">int</font> i ;
01249   
01250   <font class="comment">/* </font>
01251 <font class="comment">     res = Hermite (m, &amp;h, &amp;u);</font>
01252 <font class="comment">     if (res != m-&gt;NbRows)</font>
01253 <font class="comment">     return False ;</font>
01254 <font class="comment">  */</font>
01255   
01256   <a class="code" href="NormalForms_8c.html#a16">Hermite</a>(m, &amp;h, &amp;u);
01257   <font class="keywordflow">for</font> (i = 0; i &lt; h-&gt;NbRows; i ++)
01258     <font class="keywordflow">if</font> (<a class="code" href="arithmetique_8h.html#a67">value_zero_p</a>(h-&gt;p[i][i])) {
01259       <a class="code" href="matrix_8c.html#a1">Matrix_Free</a> (h);
01260       <a class="code" href="matrix_8c.html#a1">Matrix_Free</a> (u);
01261       <font class="keywordflow">return</font> False;
01262     }
01263   <a class="code" href="matrix_8c.html#a1">Matrix_Free</a> (h);
01264   <a class="code" href="matrix_8c.html#a1">Matrix_Free</a> (u);
01265   <font class="keywordflow">return</font> True;
01266 } <font class="comment">/* isfulldim */</font>
01267      
01268 <font class="comment">/* </font>
01269 <font class="comment"> * This function takes as input a lattice list in which the lattices have the </font>
01270 <font class="comment"> * same linear part, and almost the same affinepart, i.e. if A and B are two </font>
01271 <font class="comment"> * of the lattices in the above lattice list and [a1, .. , an] and [b1 .. bn]</font>
01272 <font class="comment"> * are the affineparts of A and B respectively, then for 0 &lt; i &lt; n ai = bi and</font>
01273 <font class="comment"> * 'an' may not be equal to 'bn'. These are not the affine parts in the n-th</font>
01274 <font class="comment"> * dimension, but the lattices have been tranformed such that the value of the </font>
01275 <font class="comment"> * elment in the dimension on which we are simplifying is in the last row and</font>
01276 <font class="comment"> * also the lattices are in a sorted order. </font>
01277 <font class="comment"> *              This function also takes as input the dimension along which we</font>
01278 <font class="comment"> * are simplifying and takes the diagonal element of the lattice along that</font>
01279 <font class="comment"> * dimension and tries to find out the factors of that element and sees if the</font>
01280 <font class="comment"> * list of lattices can be simplified using these factors. The output of this </font>
01281 <font class="comment"> * function is the list of lattices in the simplified form and a flag to indic-</font>
01282 <font class="comment"> * ate whether any form of simplification was actually done or not.  </font>
01283 <font class="comment"> */</font>
<a name="l01284"></a><a class="code" href="Lattice_8c.html#a28">01284</a> <font class="keyword">static</font> Bool <a class="code" href="Lattice_8c.html#a28">Simplify</a>(LatticeUnion **InputList, LatticeUnion **ResultList, <font class="keywordtype">int</font> dim) {
01285   
01286   <font class="keywordtype">int</font> i;
01287   LatticeUnion *prev, *temp;
01288   <a class="code" href="structfactor.html">factor</a> allfac;
01289   Bool retval = False;
01290   <font class="keywordtype">int</font> width;
01291   <a class="code" href="arithmetique_8h.html#a93">Value</a> cnt, aux, k, fac, num, tmp, foobar;
01292   
01293   <font class="keywordflow">if</font> ((*InputList == NULL) || (InputList[0]-&gt;next == NULL))
01294     <font class="keywordflow">return</font> False ;
01295 
01296   <a class="code" href="arithmetique_8h.html#a10">value_init</a>(aux); <a class="code" href="arithmetique_8h.html#a10">value_init</a>(cnt); 
01297   <a class="code" href="arithmetique_8h.html#a10">value_init</a>(k); <a class="code" href="arithmetique_8h.html#a10">value_init</a>(fac);
01298   <a class="code" href="arithmetique_8h.html#a10">value_init</a>(num); <a class="code" href="arithmetique_8h.html#a10">value_init</a>(tmp);
01299   <a class="code" href="arithmetique_8h.html#a10">value_init</a>(foobar);
01300 
01301   width = InputList[0]-&gt;M-&gt;NbRows-1; 
01302   allfac = <a class="code" href="Lattice_8c.html#a0">allfactors</a>(<a class="code" href="arithmetique_8h.html#a7">VALUE_TO_INT</a>(InputList[0]-&gt;M-&gt;p[dim][dim]));
01303   <a class="code" href="arithmetique_8h.html#a12">value_set_si</a>(cnt,0);
01304   <font class="keywordflow">for</font> (temp = InputList[0]; temp != NULL; temp = temp-&gt;next)
01305     <a class="code" href="arithmetique_8h.html#a45">value_increment</a>(cnt,cnt);  
01306   <font class="keywordflow">for</font>(i = 0; i &lt; allfac.<a class="code" href="structfactor.html#m0">count</a>; i++) {
01307     <a class="code" href="arithmetique_8h.html#a12">value_set_si</a>(foobar,allfac.<a class="code" href="structfactor.html#m1">fac</a>[i]);
01308     <a class="code" href="arithmetique_8h.html#a51">value_division</a>(aux,InputList[0]-&gt;M-&gt;p[dim][dim],foobar);
01309     <font class="keywordflow">if</font>(<a class="code" href="arithmetique_8h.html#a25">value_ge</a>(cnt,aux))
01310       <font class="keywordflow">break</font>;
01311   }
01312   <font class="keywordflow">if</font> (i == allfac.<a class="code" href="structfactor.html#m0">count</a>) {
01313     <a class="code" href="arithmetique_8h.html#a14">value_clear</a>(cnt); <a class="code" href="arithmetique_8h.html#a14">value_clear</a>(aux);   
01314     <a class="code" href="arithmetique_8h.html#a14">value_clear</a>(k); <a class="code" href="arithmetique_8h.html#a14">value_clear</a>(fac);
01315     <a class="code" href="arithmetique_8h.html#a14">value_clear</a>(num); <a class="code" href="arithmetique_8h.html#a14">value_clear</a>(tmp);
01316     <a class="code" href="arithmetique_8h.html#a14">value_clear</a>(foobar);
01317     <font class="keywordflow">return</font> False; 
01318   }
01319   <font class="keywordflow">for</font> (; i &lt; allfac.<a class="code" href="structfactor.html#m0">count</a>; i++) {    
01320     Bool Present = False;
01321     <a class="code" href="arithmetique_8h.html#a12">value_set_si</a>(k,0);
01322     
01323     <font class="keywordflow">if</font> (*InputList == NULL) {
01324       <a class="code" href="arithmetique_8h.html#a14">value_clear</a>(cnt); <a class="code" href="arithmetique_8h.html#a14">value_clear</a>(aux);
01325       <a class="code" href="arithmetique_8h.html#a14">value_clear</a>(k); <a class="code" href="arithmetique_8h.html#a14">value_clear</a>(fac);
01326       <a class="code" href="arithmetique_8h.html#a14">value_clear</a>(num); <a class="code" href="arithmetique_8h.html#a14">value_clear</a>(tmp);
01327       <a class="code" href="arithmetique_8h.html#a14">value_clear</a>(foobar);
01328       <font class="keywordflow">return</font> retval;
01329     }
01330     <a class="code" href="arithmetique_8h.html#a12">value_set_si</a>(foobar,allfac.<a class="code" href="structfactor.html#m1">fac</a>[i]);
01331     <a class="code" href="arithmetique_8h.html#a51">value_division</a>(num,InputList[0]-&gt;M-&gt;p[dim][dim],foobar);
01332     <font class="keywordflow">while</font> (<a class="code" href="arithmetique_8h.html#a26">value_lt</a>(k,foobar)) {          
01333       Present = False;
01334       <a class="code" href="arithmetique_8h.html#a11">value_assign</a>(fac,k); 
01335       <font class="keywordflow">for</font> (temp = *InputList; temp != NULL; temp = temp-&gt;next) {
01336         <font class="keywordflow">if</font> (<a class="code" href="arithmetique_8h.html#a22">value_eq</a>(temp-&gt;M-&gt;p[temp-&gt;M-&gt;NbRows-1][temp-&gt;M-&gt;NbColumns-1],fac)) {
01337           <a class="code" href="arithmetique_8h.html#a12">value_set_si</a>(foobar,allfac.<a class="code" href="structfactor.html#m1">fac</a>[i]);
01338           <a class="code" href="arithmetique_8h.html#a43">value_addto</a>(fac,fac,foobar);
01339           <font class="keywordflow">if</font> (<a class="code" href="arithmetique_8h.html#a25">value_ge</a>(fac,(*InputList)-&gt;M-&gt;p[dim][dim])) {
01340             Present = True;
01341             <font class="keywordflow">break</font>;
01342           }
01343         }       
01344         <font class="keywordflow">if</font> (<a class="code" href="arithmetique_8h.html#a24">value_gt</a>(temp-&gt;M-&gt;p[temp-&gt;M-&gt;NbRows-1][temp-&gt;M-&gt;NbColumns-1],fac))
01345           <font class="keywordflow">break</font>;
01346       }      
01347       <font class="keywordflow">if</font> (Present == True) {    
01348         retval = True;
01349         <font class="keywordflow">if</font> (*ResultList == NULL)
01350           *ResultList = temp = (LatticeUnion *)malloc(<font class="keyword">sizeof</font>(LatticeUnion));
01351         <font class="keywordflow">else</font> {
01352           <font class="keywordflow">for</font> (temp = *ResultList; temp-&gt;next != NULL; temp = temp-&gt;next);
01353           temp-&gt;next = (LatticeUnion *) malloc (<font class="keyword">sizeof</font> (LatticeUnion));
01354           temp = temp-&gt;next;
01355         }
01356         temp-&gt;M = <a class="code" href="Matop_8c.html#a5">Matrix_Copy</a>(InputList[0]-&gt;M); 
01357         temp-&gt;next = NULL;
01358         <a class="code" href="arithmetique_8h.html#a12">value_set_si</a>(foobar,allfac.<a class="code" href="structfactor.html#m1">fac</a>[i]);
01359         <a class="code" href="arithmetique_8h.html#a11">value_assign</a>(temp-&gt;M-&gt;p[dim][dim],foobar);
01360         <a class="code" href="arithmetique_8h.html#a11">value_assign</a>(temp-&gt;M-&gt;p[dim][width],k);
01361         <a class="code" href="arithmetique_8h.html#a12">value_set_si</a>(temp-&gt;M-&gt;p[width][width],1);
01362         
01363         <font class="comment">/* Deleting the Lattices from the curlist */</font>
01364         <a class="code" href="arithmetique_8h.html#a11">value_assign</a>(tmp,k);
01365         prev = NULL;
01366         temp = InputList[0];
01367         <font class="keywordflow">while</font> (temp != NULL) {
01368           <font class="keywordflow">if</font> (<a class="code" href="arithmetique_8h.html#a22">value_eq</a>(temp-&gt;M-&gt;p[width][width],tmp)) {
01369             <font class="keywordflow">if</font> (temp == InputList[0]) {
01370               prev = temp;
01371               temp = InputList [0] = temp-&gt;next;
01372               <a class="code" href="matrix_8c.html#a1">Matrix_Free</a>(prev-&gt;M);
01373               free(prev);         
01374             }
01375             <font class="keywordflow">else</font> {
01376               prev-&gt;next = temp-&gt;next;
01377               <a class="code" href="matrix_8c.html#a1">Matrix_Free</a>(temp-&gt;M);
01378               free(temp);
01379               temp = prev-&gt;next;
01380             }
01381             <a class="code" href="arithmetique_8h.html#a12">value_set_si</a>(foobar,allfac.<a class="code" href="structfactor.html#m1">fac</a>[i]);
01382             <a class="code" href="arithmetique_8h.html#a43">value_addto</a>(tmp,tmp,foobar); 
01383           }
01384           <font class="keywordflow">else</font> {
01385             prev = temp;
01386             temp = temp-&gt;next;
01387           }
01388         }   
01389       } 
01390       <a class="code" href="arithmetique_8h.html#a45">value_increment</a>(k,k);
01391     }    
01392   }
01393   <a class="code" href="arithmetique_8h.html#a14">value_clear</a>(cnt); <a class="code" href="arithmetique_8h.html#a14">value_clear</a>(aux);
01394   <a class="code" href="arithmetique_8h.html#a14">value_clear</a>(k); <a class="code" href="arithmetique_8h.html#a14">value_clear</a>(fac);
01395   <a class="code" href="arithmetique_8h.html#a14">value_clear</a>(num); <a class="code" href="arithmetique_8h.html#a14">value_clear</a>(tmp);
01396   <a class="code" href="arithmetique_8h.html#a14">value_clear</a>(foobar);
01397   <font class="keywordflow">return</font> retval;          
01398 } <font class="comment">/* Simplify */</font>     
01399  
01400 <font class="comment">/*</font>
01401 <font class="comment"> * This function is used in the qsort function in sorting the lattices. Given </font>
01402 <font class="comment"> * two lattices 'A' and 'B', both in HNF, where A = [ [a11 0], [a21, a22, 0] .</font>
01403 <font class="comment"> * .... [an1, .., ann] ] and B = [ [b11 0], [b21, b22, 0] ..[bn1, .., bnn] ],</font>
01404 <font class="comment"> * then A &lt; B, if there exists a pair &lt;i,j&gt; such that [aij &lt; bij] and for every</font>
01405 <font class="comment"> * other pair &lt;i1, j1&gt;, 0&lt;=i1&lt;i, 0&lt;=j1&lt;j [ai1j1 = bi1j1]. </font>
01406 <font class="comment"> */</font>
<a name="l01407"></a><a class="code" href="Lattice_8c.html#a29">01407</a> <font class="keyword">static</font> <font class="keywordtype">int</font> <a class="code" href="Lattice_8c.html#a29">LinearPartCompare</a>(<font class="keyword">const</font> <font class="keywordtype">void</font> *A, <font class="keyword">const</font> <font class="keywordtype">void</font> *B) {
01408  
01409   Lattice **L1, **L2;
01410   <font class="keywordtype">int</font> i, j;
01411   
01412   L1 = (Lattice **) A; 
01413   L2 = (Lattice **) B;
01414   
01415   <font class="keywordflow">for</font> (i = 0;  i &lt; L1[0]-&gt;NbRows-1; i++)
01416     <font class="keywordflow">for</font> (j = 0; j &lt;= i ; j++) {
01417       <font class="keywordflow">if</font> (<a class="code" href="arithmetique_8h.html#a24">value_gt</a>(L1[0]-&gt;p[i][j],L2[0]-&gt;p[i][j]))
01418         <font class="keywordflow">return</font> 1;      
01419       <font class="keywordflow">if</font> (<a class="code" href="arithmetique_8h.html#a26">value_lt</a>(L1[0]-&gt;p[i][j],L2[0]-&gt;p[i][j]))
01420         <font class="keywordflow">return</font> -1;
01421     }   
01422   <font class="keywordflow">return</font> 0;
01423 } <font class="comment">/* LinearPartCompare */</font>
01424   
01425 <font class="comment">/*</font>
01426 <font class="comment"> * This function takes as input a List of Lattices and sorts them on the basis</font>
01427 <font class="comment"> * of their Linear parts. It sorts in place, as a result of which the input </font>
01428 <font class="comment"> * list is modified to the sorted order.</font>
01429 <font class="comment"> */</font> 
<a name="l01430"></a><a class="code" href="Lattice_8c.html#a30">01430</a> <font class="keyword">static</font> <font class="keywordtype">void</font> <a class="code" href="Lattice_8c.html#a30">LinearPartSort</a> (LatticeUnion *Head) {
01431 
01432   <font class="keywordtype">int</font>  cnt;
01433   Lattice **Latlist;
01434   LatticeUnion *temp ;
01435   
01436   cnt = 0;
01437   <font class="keywordflow">for</font> (temp = Head; temp != NULL; temp = temp-&gt;next)
01438     cnt ++;
01439  
01440   Latlist = (Lattice **) malloc ( <font class="keyword">sizeof</font> (Lattice *) * cnt);
01441   
01442   cnt = 0; 
01443   <font class="keywordflow">for</font> (temp = Head; temp != NULL; temp = temp-&gt;next)
01444     Latlist[cnt++] = temp-&gt;M; 
01445   
01446   qsort(Latlist, cnt, <font class="keyword">sizeof</font>(Lattice *), <a class="code" href="Lattice_8c.html#a29">LinearPartCompare</a>);
01447   
01448   cnt = 0;  
01449   <font class="keywordflow">for</font> (temp = Head; temp != NULL; temp = temp-&gt;next)
01450     temp-&gt;M = Latlist[cnt++];
01451   
01452  free (Latlist);
01453  <font class="keywordflow">return</font>;
01454 } <font class="comment">/* LinearPartSort */</font>
01455 
01456 <font class="comment">/*</font>
01457 <font class="comment"> * This function is used in 'AfiinePartSort' in sorting the lattices with the</font>
01458 <font class="comment"> * same linear part. GIven two lattices 'A' and 'B' with affineparts [a1 .. an]</font>
01459 <font class="comment"> * and [b1 ... bn], then A &lt; B if for some 0 &lt; i &lt;= n, ai &lt; bi and for 0 &lt; i1 &lt;</font>
01460 <font class="comment"> * i, ai1 = bi1. </font>
01461 <font class="comment"> */</font> 
<a name="l01462"></a><a class="code" href="Lattice_8c.html#a31">01462</a> <font class="keyword">static</font> <font class="keywordtype">int</font> <a class="code" href="Lattice_8c.html#a31">AffinePartCompare</a>(<font class="keyword">const</font> <font class="keywordtype">void</font> *A, <font class="keyword">const</font> <font class="keywordtype">void</font> *B) {
01463   
01464   <font class="keywordtype">int</font> i;
01465   Lattice **L1, **L2; 
01466 
01467   L1 = (Lattice **)A;
01468   L2 = (Lattice **)B;
01469   
01470   <font class="keywordflow">for</font> (i = 0; i &lt; L1[0]-&gt;NbRows; i++) {
01471     <font class="keywordflow">if</font> (<a class="code" href="arithmetique_8h.html#a24">value_gt</a>(L1[0]-&gt;p[i][L1[0]-&gt;NbColumns-1],L2[0]-&gt;p[i][L1[0]-&gt;NbColumns-1]))
01472       <font class="keywordflow">return</font> 1;  
01473     
01474     <font class="keywordflow">if</font> (<a class="code" href="arithmetique_8h.html#a26">value_lt</a>(L1[0]-&gt;p[i][L1[0]-&gt;NbColumns-1],L2[0]-&gt;p[i][L1[0]-&gt;NbColumns-1]))
01475       <font class="keywordflow">return</font> -1;  
01476   }  
01477   <font class="keywordflow">return</font> 0 ;
01478 } <font class="comment">/* AffinePartCompare */</font>
01479 
01480 <font class="comment">/* </font>
01481 <font class="comment"> * This function takes a list of lattices with the same linear part and sorts</font>
01482 <font class="comment"> * them on the basis of their affine part. The sorting is done in place.</font>
01483 <font class="comment"> */</font>
<a name="l01484"></a><a class="code" href="Lattice_8c.html#a32">01484</a> <font class="keyword">static</font> <font class="keywordtype">void</font> <a class="code" href="Lattice_8c.html#a32">AffinePartSort</a> (LatticeUnion *List) {
01485   
01486   <font class="keywordtype">int</font> cnt;
01487   Lattice **LatList;
01488   LatticeUnion *tmp;
01489   
01490   cnt = 0;
01491   <font class="keywordflow">for</font> (tmp = List; tmp != NULL; tmp = tmp-&gt;next)
01492     cnt ++;  
01493   
01494   LatList = (Lattice **) malloc (<font class="keyword">sizeof</font>(Lattice *) * cnt);
01495   
01496   cnt = 0;
01497   <font class="keywordflow">for</font> (tmp = List; tmp != NULL; tmp = tmp-&gt;next)
01498     LatList[cnt++] = tmp-&gt;M;
01499   
01500   qsort(LatList,cnt, <font class="keyword">sizeof</font> (Lattice *), <a class="code" href="Lattice_8c.html#a31">AffinePartCompare</a>);
01501   
01502   cnt = 0;
01503   <font class="keywordflow">for</font> (tmp = List; tmp != NULL; tmp = tmp-&gt;next) 
01504     tmp-&gt;M = LatList[cnt++];
01505   <font class="keywordflow">return</font>;
01506 } <font class="comment">/* AffinePartSort */</font>
01507 
<a name="l01508"></a><a class="code" href="Lattice_8c.html#a33">01508</a> <font class="keyword">static</font> Bool <a class="code" href="Lattice_8c.html#a33">AlmostSameAffinePart</a>(LatticeUnion *A, LatticeUnion *B) {
01509   
01510   <font class="keywordtype">int</font> i;
01511   
01512   <font class="keywordflow">if</font> ((A == NULL) || (B == NULL))
01513     <font class="keywordflow">return</font> False;
01514 
01515   <font class="keywordflow">for</font> (i = 0; i &lt; A-&gt;M-&gt;NbRows-1; i ++)
01516     <font class="keywordflow">if</font> (<a class="code" href="arithmetique_8h.html#a23">value_ne</a>(A-&gt;M-&gt;p[i][A-&gt;M-&gt;NbColumns-1],B-&gt;M-&gt;p[i][A-&gt;M-&gt;NbColumns-1]))
01517       <font class="keywordflow">return</font> False;   
01518   <font class="keywordflow">return</font> True;
01519 } <font class="comment">/* AlmostSameAffinePart */</font>
01520 
01521 <font class="comment">/* </font>
01522 <font class="comment"> * This function takes a list of lattices having the same linear part and tries</font>
01523 <font class="comment"> * to simplify these lattices. This may not be the only way of simplifying the</font>
01524 <font class="comment"> * lattices. The function returns a list of partially simplified lattices and </font>
01525 <font class="comment"> * also a flag to tell whether any simplification was performed at all. </font>
01526 <font class="comment"> */</font>
<a name="l01527"></a><a class="code" href="Lattice_8c.html#a34">01527</a> <font class="keyword">static</font> Bool <a class="code" href="Lattice_8c.html#a34">AffinePartSimplify</a>(LatticeUnion *curlist, LatticeUnion **newlist) {
01528   
01529   <font class="keywordtype">int</font> i;
01530   <a class="code" href="arithmetique_8h.html#a93">Value</a> aux;
01531   LatticeUnion *temp, *curr, *next;
01532   LatticeUnion *nextlist;
01533   Bool change = False, chng;
01534   
01535   <font class="keywordflow">if</font> (curlist == NULL) 
01536     <font class="keywordflow">return</font> False;
01537   
01538   <font class="keywordflow">if</font> (curlist-&gt;next == NULL) {
01539     curlist-&gt;next = newlist[0];
01540     newlist[0] = curlist;
01541     <font class="keywordflow">return</font> False ;
01542   }
01543   
01544   <a class="code" href="arithmetique_8h.html#a10">value_init</a>(aux);
01545   <font class="keywordflow">for</font> (i = 0; i &lt; curlist-&gt;M-&gt;NbRows - 1; i ++) {
01546     
01547     <font class="comment">/* Interchanging the elements of the Affine part for easy computation</font>
01548 <font class="comment">       of the sort (using qsort) */</font>
01549     
01550     <font class="keywordflow">for</font> (temp = curlist; temp != NULL; temp = temp-&gt;next) {      
01551       <a class="code" href="arithmetique_8h.html#a11">value_assign</a>(aux,temp-&gt;M-&gt;p[temp-&gt;M-&gt;NbRows-1][temp-&gt;M-&gt;NbColumns-1]);
01552       <a class="code" href="arithmetique_8h.html#a11">value_assign</a>(temp-&gt;M-&gt;p[temp-&gt;M-&gt;NbRows-1][temp-&gt;M-&gt;NbColumns-1],temp-&gt;M-&gt;p[i][temp-&gt;M-&gt;NbColumns-1]);
01553       <a class="code" href="arithmetique_8h.html#a11">value_assign</a>(temp-&gt;M-&gt;p[i][temp-&gt;M-&gt;NbColumns-1],aux);
01554     }     
01555     <a class="code" href="Lattice_8c.html#a32">AffinePartSort</a>(curlist);
01556     nextlist = NULL;
01557     curr = curlist;
01558     <font class="keywordflow">while</font> (curr != NULL) {
01559       next = curr-&gt;next;
01560       <font class="keywordflow">if</font> (!<a class="code" href="Lattice_8c.html#a33">AlmostSameAffinePart</a>(curr, next)) {
01561         curr-&gt;next = NULL;
01562         chng = <a class="code" href="Lattice_8c.html#a28">Simplify</a>(&amp;curlist, newlist, i);
01563         <font class="keywordflow">if</font> (nextlist == NULL)
01564           nextlist = curlist;
01565         <font class="keywordflow">else</font> {
01566           LatticeUnion *tmp;
01567           <font class="keywordflow">for</font> (tmp = nextlist; tmp-&gt;next; tmp=tmp-&gt;next);
01568           tmp-&gt;next = curlist;
01569         }
01570         change = change | chng ;
01571         curlist = next;
01572       }
01573       curr = next;
01574     }  
01575     curlist = nextlist;
01576     
01577     <font class="comment">/* Interchanging the elements of the Affine part for easy computation</font>
01578 <font class="comment">       of the sort (using qsort) */</font>
01579     
01580     <font class="keywordflow">for</font>(temp = curlist; temp != NULL; temp = temp-&gt;next) {
01581       <a class="code" href="arithmetique_8h.html#a11">value_assign</a>(aux,temp-&gt;M-&gt;p[temp-&gt;M-&gt;NbRows-1][temp-&gt;M-&gt;NbColumns-1]);
01582       <a class="code" href="arithmetique_8h.html#a11">value_assign</a>(temp-&gt;M-&gt;p[temp-&gt;M-&gt;NbRows-1][temp-&gt;M-&gt;NbColumns-1],temp-&gt;M-&gt;p[i][temp-&gt;M-&gt;NbColumns-1]);
01583       <a class="code" href="arithmetique_8h.html#a11">value_assign</a>(temp-&gt;M-&gt;p[i][temp-&gt;M-&gt;NbColumns-1],aux);
01584     }     
01585     <font class="keywordflow">if</font> (curlist == NULL)
01586       <font class="keywordflow">break</font>;
01587   }
01588   <font class="keywordflow">if</font> ( *newlist == NULL)
01589     *newlist = nextlist;
01590   <font class="keywordflow">else</font> {
01591     <font class="keywordflow">for</font> (curr = *newlist; curr-&gt;next != NULL; curr = curr-&gt;next);
01592     curr-&gt;next = nextlist;
01593   }  
01594   <a class="code" href="arithmetique_8h.html#a14">value_clear</a>(aux);
01595   <font class="keywordflow">return</font> change;
01596 } <font class="comment">/* AffinePartSimplify */</font>
01597      
<a name="l01598"></a><a class="code" href="Lattice_8c.html#a35">01598</a> <font class="keyword">static</font> Bool <a class="code" href="Lattice_8c.html#a35">SameLinearPart</a>(LatticeUnion *A, LatticeUnion *B) {
01599   
01600   <font class="keywordtype">int</font> i, j;  
01601   <font class="keywordflow">if</font> ((A == NULL) || (B ==NULL))
01602     <font class="keywordflow">return</font> False;
01603   <font class="keywordflow">for</font> (i = 0; i &lt; A-&gt;M-&gt;NbRows-1; i++)
01604     <font class="keywordflow">for</font> (j = 0; j &lt;= i; j++)
01605       <font class="keywordflow">if</font> (<a class="code" href="arithmetique_8h.html#a23">value_ne</a>(A-&gt;M-&gt;p[i][j],B-&gt;M-&gt;p[i][j]))
01606         <font class="keywordflow">return</font> False;
01607   
01608   <font class="keywordflow">return</font> True;
01609 } <font class="comment">/* SameLinearPart */</font>
01610 
01611 <font class="comment">/* </font>
01612 <font class="comment"> * Given a union of lattices, return a simplified list of lattices. </font>
01613 <font class="comment"> */</font> 
<a name="l01614"></a><a class="code" href="Lattice_8c.html#a36">01614</a> LatticeUnion *<a class="code" href="Lattice_8c.html#a36">LatticeSimplify</a>(LatticeUnion *latlist) {
01615   
01616   LatticeUnion  *curlist, *nextlist;
01617   LatticeUnion *curr, *next;
01618   Bool change = True, chng;
01619   
01620   curlist = latlist;
01621   <font class="keywordflow">while</font> (change == True) {
01622     change = False;
01623     <a class="code" href="Lattice_8c.html#a30">LinearPartSort</a>(curlist);
01624     curr = curlist;
01625     nextlist = NULL;
01626     <font class="keywordflow">while</font>(curr != NULL) {
01627       next = curr-&gt;next;
01628       <font class="keywordflow">if</font> (!<a class="code" href="Lattice_8c.html#a35">SameLinearPart</a>(curr, next)) {
01629         curr-&gt;next = NULL; 
01630         chng = <a class="code" href="Lattice_8c.html#a34">AffinePartSimplify</a>(curlist, &amp;nextlist);
01631         change = change | chng ;
01632         curlist = next; 
01633       }
01634       curr = next; 
01635     }
01636     curlist = nextlist; 
01637   }
01638   <font class="keywordflow">return</font> curlist;
01639 } <font class="comment">/* LatticeSimplify */</font>
01640 
<a name="l01641"></a><a class="code" href="Lattice_8c.html#a37">01641</a> <font class="keywordtype">int</font> <a class="code" href="Lattice_8c.html#a37">intcompare</a> (<font class="keyword">const</font> <font class="keywordtype">void</font> *a, <font class="keyword">const</font> <font class="keywordtype">void</font> *b) {
01642 
01643   <font class="keywordtype">int</font> *i, *j;
01644   
01645   i = (<font class="keywordtype">int</font> *) a;
01646   j = (<font class="keywordtype">int</font> *) b;
01647   <font class="keywordflow">if</font> (*i &gt; *j)
01648     <font class="keywordflow">return</font> 1;
01649   <font class="keywordflow">if</font> (*i &lt; *j)
01650     <font class="keywordflow">return</font> -1;
01651   <font class="keywordflow">return</font> 0;
01652 } <font class="comment">/* intcompare */</font>
01653 
01654 <font class="keyword">static</font> <font class="keywordtype">int</font> <a class="code" href="Lattice_8c.html#a38">polylib_sqrt</a>(<font class="keywordtype">int</font> i);
<a name="l01655"></a><a class="code" href="Lattice_8c.html#a0">01655</a> <font class="keyword">static</font> <a class="code" href="structfactor.html">factor</a> <a class="code" href="Lattice_8c.html#a0">allfactors</a> (<font class="keywordtype">int</font> num) {
01656  
01657   <font class="keywordtype">int</font> i,j, tmp;
01658   <font class="keywordtype">int</font> noofelmts = 1;
01659   <font class="keywordtype">int</font> *list, *newlist;
01660   <font class="keywordtype">int</font> count;
01661   <a class="code" href="structfactor.html">factor</a> result;
01662   
01663   list = (<font class="keywordtype">int</font> *)malloc(<font class="keyword">sizeof</font> (<font class="keywordtype">int</font>));
01664   list[0] = 1;
01665   
01666   tmp = num;
01667   <font class="keywordflow">for</font> (i = 2; i &lt;= <a class="code" href="Lattice_8c.html#a38">polylib_sqrt</a>(tmp); i++) {
01668     <font class="keywordflow">if</font> ((tmp % i) == 0) {
01669       <font class="keywordflow">if</font> (noofelmts == 0) {
01670         list = (<font class="keywordtype">int</font> *) malloc (<font class="keyword">sizeof</font> (<font class="keywordtype">int</font>));
01671         list[0] = i;
01672         noofelmts = 1;
01673       }
01674       <font class="keywordflow">else</font> {
01675         newlist = (<font class="keywordtype">int</font> *) malloc (<font class="keyword">sizeof</font> (<font class="keywordtype">int</font>) * 2 * noofelmts + 1);
01676         <font class="keywordflow">for</font> (j = 0; j &lt; noofelmts; j++)
01677           newlist[j] = list[j] ;
01678         newlist[j] = i;
01679         <font class="keywordflow">for</font> (j = 0; j &lt; noofelmts; j++)
01680           newlist[j+noofelmts+1] = i * list[j];
01681         free (list);
01682         list = newlist;
01683         noofelmts= 2*noofelmts+1;
01684       }
01685       tmp = tmp / i;
01686       i = 1;
01687     } 
01688   }
01689   
01690   <font class="keywordflow">if</font> ((tmp != 0) &amp;&amp; (tmp != num)) {
01691     newlist = (<font class="keywordtype">int</font> *) malloc (<font class="keyword">sizeof</font> (<font class="keywordtype">int</font>) * 2 * noofelmts + 1);
01692     <font class="keywordflow">for</font> (j = 0; j &lt; noofelmts; j ++)
01693       newlist[j] = list[j] ;
01694     newlist[j] = tmp;
01695     <font class="keywordflow">for</font> (j = 0; j &lt; noofelmts; j ++)
01696       newlist[j+noofelmts+1] = tmp * list[j];
01697     free (list);
01698     list = newlist;
01699     noofelmts= 2*noofelmts+1;
01700   }  
01701   qsort (list, noofelmts, <font class="keyword">sizeof</font>(<font class="keywordtype">int</font>), <a class="code" href="Lattice_8c.html#a37">intcompare</a>);
01702   count = 1;
01703   <font class="keywordflow">for</font> (i = 1; i &lt; noofelmts; i ++)
01704     <font class="keywordflow">if</font> (list[i] != list[i-1])
01705       list[count++] = list[i]; 
01706   <font class="keywordflow">if</font> (list[count-1] == num)
01707     count --;
01708   
01709   result.<a class="code" href="structfactor.html#m1">fac</a> = (<font class="keywordtype">int</font> *) malloc (<font class="keyword">sizeof</font> (<font class="keywordtype">int</font>) * count);
01710   result.<a class="code" href="structfactor.html#m0">count</a> = count;
01711   <font class="keywordflow">for</font> (i = 0; i &lt; count; i ++)
01712     result.<a class="code" href="structfactor.html#m1">fac</a>[i] = list[i];
01713   free (list); 
01714   <font class="keywordflow">return</font> result;
01715 } <font class="comment">/* allfactors */</font>
01716 
<a name="l01717"></a><a class="code" href="Lattice_8c.html#a38">01717</a> <font class="keyword">static</font> <font class="keywordtype">int</font> <a class="code" href="Lattice_8c.html#a38">polylib_sqrt</a> (<font class="keywordtype">int</font> i) {
01718   
01719   <font class="keywordtype">int</font> j;
01720   j = 0;
01721   i = i &gt; 0 ? i : -i;
01722   
01723   <font class="keywordflow">while</font> (1) {
01724     <font class="keywordflow">if</font> ((j * j) &gt; i)
01725       <font class="keywordflow">break</font>;
01726     <font class="keywordflow">else</font>
01727       j ++;
01728   }
01729   <font class="keywordflow">return</font> (j-1);
01730 } <font class="comment">/* polylib_sqrt */</font>
01731 
01732 
01733 
01734 
01735 
01736 
01737 
</pre></div><hr><address align="right"><small>Generated on Fri Nov 8 12:10:06 2002 for Polylib by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.15 </small></address>
</body>
</html>
